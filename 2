import pandas as pd

# Load the CSV data
df = pd.read_csv('your_filtered_data.csv', skiprows=2)  # Adjust skiprows if needed

# Convert the 'Interval' column to datetime format
df['Interval'] = pd.to_datetime(df['Interval'])

# Sort the data by 'Interval' just in case it is not sorted
df = df.sort_values('Interval')

# Check for missing values and handle them (if any)
df = df.fillna(method='ffill')

print(df.head())



from statsmodels.tsa.arima.model import ARIMA
import numpy as np

# We will focus on the 'Average' column for the time series prediction
series = df.set_index('Interval')['Average']

# Split the data into training and testing sets
train_size = int(len(series) * 0.8)
train, test = series[:train_size], series[train_size:]

# Fit the ARIMA model (you can adjust the order based on ACF/PACF analysis)
model = ARIMA(train, order=(5,1,0))
model_fit = model.fit()

# Summary of the model
print(model_fit.summary())



from sklearn.metrics import mean_absolute_error

# Forecast the test set
forecast = model_fit.forecast(steps=len(test))

# Calculate accuracy
mae = mean_absolute_error(test, forecast)
print(f'Mean Absolute Error: {mae}')

# Combine the actual and predicted values for comparison
df_forecast = pd.DataFrame({'Actual': test, 'Forecast': forecast}, index=test.index)

print(df_forecast.head())


# Forecast the next day's average value
next_day_forecast = model_fit.forecast(steps=1)
print(f'Next Day Forecast: {next_day_forecast[0]}')



#######################
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error
import warnings

warnings.filterwarnings('ignore')

# Step 1: Load and Clean Data
def load_and_clean_data(filepath):
    # Load the CSV data with the correct header row
    df = pd.read_csv(filepath, skiprows=2)  # Adjust skiprows if needed
    df.columns = df.columns.str.strip()  # Remove any leading/trailing spaces in column names
    
    # Convert the 'Interval' column to datetime format
    df['Interval'] = pd.to_datetime(df['Interval'], errors='coerce')
    
    # Drop rows with missing 'Interval' values (if any)
    df.dropna(subset=['Interval'], inplace=True)
    
    # Set 'Interval' as the index
    df.set_index('Interval', inplace=True)
    
    # Sort the data by 'Interval'
    df.sort_index(inplace=True)
    
    # Handle any other missing values (optional: forward fill, backward fill, or drop)
    df.fillna(method='ffill', inplace=True)
    
    return df

# Step 2: Train and Forecast
def train_and_forecast(df, target_column='Average', forecast_days=1):
    # Use the target column for time series prediction
    series = df[target_column]
    
    # Split the data into training and testing sets
    train_size = int(len(series) * 0.8)
    train, test = series[:train_size], series[train_size:]
    
    # Fit the ARIMA model (order can be tuned based on ACF/PACF analysis)
    model = ARIMA(train, order=(5, 1, 0))
    model_fit = model.fit()
    
    # Forecast the test set
    forecast = model_fit.predict(start=len(train), end=len(train)+len(test)-1, dynamic=False)
    
    # Calculate accuracy using Mean Absolute Error (MAE)
    mae = mean_absolute_error(test, forecast)
    print(f'Mean Absolute Error: {mae}')
    
    # Combine the actual and predicted values for comparison
    df_forecast = pd.DataFrame({'Actual': test, 'Forecast': forecast}, index=test.index)
    print(df_forecast.head())
    
    # Forecast the next 'forecast_days' days
    future_forecast = model_fit.forecast(steps=forecast_days)
    print(f'Next {forecast_days} Day(s) Forecast: {future_forecast}')
    
    return df_forecast, future_forecast

# Step 3: Execution
filepath = 'your_filtered_data.csv'  # Replace with your actual file path
df = load_and_clean_data(filepath)
df_forecast, future_forecast = train_and_forecast(df, target_column='Average', forecast_days=1)

# Optional: Save the forecast results to a CSV file
df_forecast.to_csv('forecast_results.csv')

###################################################

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error

# Load and clean data
df = pd.read_csv('your_data.csv', skiprows=3)  # Adjust if the header row is not in the first line
df = df[['Rule', 'Interval', 'Average', 'Max', 'Min', 'StandardDeviation']]
df['Interval'] = pd.to_datetime(df['Interval'])
df = df.sort_values('Interval')

# Separate CPU and Memory data
cpu_data = df[df['Rule'].str.contains('processor', case=False)]
memory_data = df[df['Rule'].str.contains('memory', case=False)]

def forecast_and_plot(data, title):
    # Train ARIMA model
    model = ARIMA(data['Average'], order=(5, 1, 0))
    model_fit = model.fit()

    # Forecast the next day
    forecast = model_fit.forecast(steps=1)[0]
    
    # Calculate MAE
    predictions = model_fit.predict(start=0, end=len(data) - 1, dynamic=False)
    mae = mean_absolute_error(data['Average'], predictions)
    print(f'Mean Absolute Error: {mae}')

    # Plot actual vs forecast
    plt.figure(figsize=(10, 6))
    plt.plot(data['Interval'], data['Average'], label='Actual')
    plt.plot(data['Interval'], predictions, color='red', label='Forecast')
    plt.title(f'{title} Usage: Actual vs Forecast')
    plt.xlabel('Date')
    plt.ylabel('Usage')
    plt.legend()
    plt.show()

    print(f'Next Day Forecast: {forecast}')

# Forecast and plot for CPU
forecast_and_plot(cpu_data, 'CPU')

# Forecast and plot for Memory
forecast_and_plot(memory_data, 'Memory')

