# Function to run PowerShell command on a remote machine
function Run-PowerShellCommand {
    param (
        [string]$AssetName,
        [string]$Command
    )

    Write-Host "Running command on ${AssetName}: $Command"
    $sessionCommand = Invoke-Command -ComputerName $AssetName -ScriptBlock {Invoke-Expression $using:Command}
    return $sessionCommand
}

# Function to get SentinelOne version
function Get-SentinelOneVersion {
    param (
        [string]$AssetName
    )

    $sentinelFolder = Run-PowerShellCommand -AssetName $AssetName -Command '(Get-ChildItem "C:\Program Files\SentinelOne" | Where-Object { $_.PSIsContainer }).FullName'
    
    if ($sentinelFolder) {
        $sentinelVersion = Run-PowerShellCommand -AssetName $AssetName -Command "(Get-Item '$sentinelFolder\SentinelAgent.exe').VersionInfo.ProductVersion"
        return $sentinelVersion.Trim()
    } else {
        return "SentinelOne folder not found"
    }
}

# Function to check for security patches
function Check-SecurityPatches {
    param (
        [string]$AssetName
    )

    $securityPatchesCommand = 'Get-WmiObject -Class win32_quickfixengineering'
    $output = Run-PowerShellCommand -AssetName $AssetName -Command $securityPatchesCommand

    if (-not $output) {
        return "No Security Patches Found"
    }

    $patchLines = $output -split "`n"
    $securityUpdates = @()
    $dateRegex = '(\d{1,2}[/-]\d{1,2}[/-]\d{4})'
    $hotfixRegex = '(KB\d{7})'

    foreach ($line in $patchLines) {
        if ($line -match "Security Update") {
            $dateMatch = [regex]::Match($line, $dateRegex)
            $hotfixMatch = [regex]::Match($line, $hotfixRegex)

            if ($dateMatch.Success -and $hotfixMatch.Success) {
                $installedOnStr = $dateMatch.Value
                $hotfixId = $hotfixMatch.Value
                try {
                    $installedOnDate = [datetime]::ParseExact($installedOnStr, "dd-MM-yyyy", $null)
                    $securityUpdates += [pscustomobject]@{
                        InstalledOn = $installedOnDate
                        HotfixID = $hotfixId
                    }
                } catch {
                    continue
                }
            }
        }
    }

    if ($securityUpdates.Count -gt 0) {
        $latestUpdate = $securityUpdates | Sort-Object InstalledOn -Descending | Select-Object -First 1
        return "Latest Security Patch Installed On: $($latestUpdate.InstalledOn.ToString('dd-MM-yyyy')) (HotFixID: $($latestUpdate.HotfixID))"
    } else {
        return "No Security Updates Found"
    }
}

# Function to check NTP configuration
function Check-NTP {
    param (
        [string]$AssetName
    )

    $ntpCommand = 'w32tm /query /status'
    $output = Run-PowerShellCommand -AssetName $AssetName -Command $ntpCommand

    if ($output -match "Source") {
        $ntpSource = ($output -split "Source: ")[1] -split "`n" | Select-Object -First 1
        return $ntpSource
    } else {
        return "NTP Not Configured"
    }
}

# Function to check Windows compliance
function Check-ComplianceWindows {
    param (
        [string]$AssetName
    )

    $compliance = @{}

    # OS information
    $osInfo = Run-PowerShellCommand -AssetName $AssetName -Command '(Get-WmiObject -Class Win32_OperatingSystem).Caption'
    $compliance["OS"] = $osInfo.Trim()

    # SentinelOne status
    $sentinelStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'Get-Service -Name "SentinelAgent"'
    if ($sentinelStatus -match "Running") {
        $sentinelVersion = Get-SentinelOneVersion -AssetName $AssetName
        $compliance["SentinelOne"] = "Running (Version: $sentinelVersion)"
    } else {
        $compliance["SentinelOne"] = "Not Installed or Not Running"
    }

    # Security patches
    $compliance["Patches"] = Check-SecurityPatches -AssetName $AssetName

    # NTP configuration
    $compliance["NTP"] = Check-NTP -AssetName $AssetName

    # Windows activation status
    $activationStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'powershell "Get-CimInstance -ClassName SoftwareLicensingProduct | Where-Object { $_.PartialProductKey } | Select-Object LicenseStatus"'
    if ($activationStatus -match "1") {
        $compliance["WindowsActivation"] = "Activated"
    } else {
        $compliance["WindowsActivation"] = "Not Activated"
    }

    # WinCollect status
    $wincollectStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'Get-Service -Name "WinCollect"'
    $compliance["WinCollect"] = $wincollectStatus.Trim()

    return $compliance
}

# Load Excel file
function Load-Excel {
    param (
        [string]$FilePath
    )

    $excel = New-Object -ComObject Excel.Application
    $workbook = $excel.Workbooks.Open($FilePath)
    $sheet = $workbook.Sheets.Item(1)
    return $workbook, $sheet
}

# Main function
function Main {
    $filePath = "D:\VS CODE\python\comp\\servers_list.xlsx"
    $workbook, $sheet = Load-Excel -FilePath $filePath

    $headers = @('OS', 'SentinelOne', 'Patches', 'NTP', 'WindowsActivation', 'WinCollect')
    for ($i = 0; $i -lt $headers.Length; $i++) {
        $sheet.Cells.Item(1, $i + 3).Value2 = $headers[$i]
    }

    $rowCount = $sheet.UsedRange.Rows.Count
    for ($row = 2; $row -le $rowCount; $row++) {
        $assetName = $sheet.Cells.Item($row, 1).Value2
        Write-Host "Checking $assetName..."
        $complianceResults = Check-ComplianceWindows -AssetName $assetName

        $colIndex = 3
        foreach ($result in $complianceResults.Values) {
            $sheet.Cells.Item($row, $colIndex).Value2 = $result
            $colIndex++
        }
    }

    $workbook.Save()
    $workbook.Close()
    Write-Host "Compliance report generated successfully."
}

# Run the script
Main
