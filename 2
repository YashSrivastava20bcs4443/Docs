trigger:
- none

parameters:
  - name: osType
    displayName: "OS Type (linux/windows)"
    type: string
    default: "linux"
    values:
      - linux
      - windows
  - name: vmSize
    displayName: "VM Size"
    type: string
    default: "Standard_D2s_v3"
  - name: nicCount
    displayName: "Number of NICs"
    type: number
    default: 1
  - name: linuxVmCount
    displayName: "Number of Linux VMs"
    type: number
    default: 1
  - name: windowsVmCount
    displayName: "Number of Windows VMs"
    type: number
    default: 0

variables:
- group: TerraformVars  # ✅ Variable group for sensitive values
- name: terraformVarsFile
  value: "$(Build.SourcesDirectory)/terraform.tfvars"  # Path to tfvars file

jobs:
- job: Terraform_Deploy
  displayName: "Terraform Apply"
  pool:
    vmImage: ubuntu-latest  # Microsoft-hosted agent

  steps:
  - checkout: self  # ✅ Ensures repo is checked out

  # ✅ Step 1: Generate terraform.tfvars dynamically
  - script: |
      echo "linux_vm_count=${{ parameters.linuxVmCount }}" > $(terraformVarsFile)
      echo "windows_vm_count=${{ parameters.windowsVmCount }}" >> $(terraformVarsFile)
      echo "linux_vm_config = {" >> $(terraformVarsFile)
      echo "  os_type = \"linux\"" >> $(terraformVarsFile)
      echo "  vm_size = \"${{ parameters.vmSize }}\"" >> $(terraformVarsFile)
      echo "  nic_count = ${{ parameters.nicCount }}" >> $(terraformVarsFile)
      echo "  admin_username = \"$(ADMIN_USERNAME)\"" >> $(terraformVarsFile)
      echo "  admin_password = \"$(ADMIN_PASSWORD)\"" >> $(terraformVarsFile)
      echo "  public_ip = false" >> $(terraformVarsFile)
      echo "  image_reference = {" >> $(terraformVarsFile)
      echo "    publisher = \"Canonical\"" >> $(terraformVarsFile)
      echo "    offer = \"UbuntuServer\"" >> $(terraformVarsFile)
      echo "    sku = \"18.04-LTS\"" >> $(terraformVarsFile)
      echo "    version = \"latest\"" >> $(terraformVarsFile)
      echo "  }" >> $(terraformVarsFile)
      echo "}" >> $(terraformVarsFile)

      echo "windows_vm_config = {" >> $(terraformVarsFile)
      echo "  os_type = \"windows\"" >> $(terraformVarsFile)
      echo "  vm_size = \"${{ parameters.vmSize }}\"" >> $(terraformVarsFile)
      echo "  nic_count = ${{ parameters.nicCount }}" >> $(terraformVarsFile)
      echo "  admin_username = \"$(ADMIN_USERNAME)\"" >> $(terraformVarsFile)
      echo "  admin_password = \"$(ADMIN_PASSWORD)\"" >> $(terraformVarsFile)
      echo "  public_ip = false" >> $(terraformVarsFile)
      echo "  image_reference = {" >> $(terraformVarsFile)
      echo "    publisher = \"MicrosoftWindowsServer\"" >> $(terraformVarsFile)
      echo "    offer = \"WindowsServer\"" >> $(terraformVarsFile)
      echo "    sku = \"2019-Datacenter\"" >> $(terraformVarsFile)
      echo "    version = \"latest\"" >> $(terraformVarsFile)
      echo "  }" >> $(terraformVarsFile)
      echo "}" >> $(terraformVarsFile)
    displayName: "Generate terraform.tfvars dynamically"

  # ✅ Step 2: Terraform Init using Service Connection
  - task: TerraformTaskV3@3
    displayName: "Terraform Init"
    inputs:
      provider: "azurerm"
      command: "init"
      backendServiceArm: "AzureConnection"
      backendAzureRmResourceGroupName: "tfstate-resources"
      backendAzureRmStorageAccountName: "mytfstatesstacc"
      backendAzureRmContainerName: "tfstate"
      backendAzureRmKey: "pipelinetst/terraform.tfstate"


  # ✅ Step 3: Terraform Plan
  - task: TerraformTaskV3@3
    displayName: "Terraform Plan"
    inputs:
      provider: "azurerm"
      command: "plan"
      environmentServiceNameAzureRM: "AzureConnection"
      commandOptions: "-var-file=$(terraformVarsFile) -detailed-exitcode"

  # ✅ Step 4: Terraform Apply
  - task: TerraformTaskV3@3
    displayName: "Terraform Apply"
    inputs:
      provider: "azurerm"
      command: "apply"
      environmentServiceNameAzureRM: "AzureConnection"
      commandOptions: "-var-file=$(terraformVarsFile) -auto-approve"
