import pandas as pd

# Load the CSV data
df = pd.read_csv('your_filtered_data.csv', skiprows=2)  # Adjust skiprows if needed

# Convert the 'Interval' column to datetime format
df['Interval'] = pd.to_datetime(df['Interval'])

# Sort the data by 'Interval' just in case it is not sorted
df = df.sort_values('Interval')

# Check for missing values and handle them (if any)
df = df.fillna(method='ffill')

print(df.head())



from statsmodels.tsa.arima.model import ARIMA
import numpy as np

# We will focus on the 'Average' column for the time series prediction
series = df.set_index('Interval')['Average']

# Split the data into training and testing sets
train_size = int(len(series) * 0.8)
train, test = series[:train_size], series[train_size:]

# Fit the ARIMA model (you can adjust the order based on ACF/PACF analysis)
model = ARIMA(train, order=(5,1,0))
model_fit = model.fit()

# Summary of the model
print(model_fit.summary())



from sklearn.metrics import mean_absolute_error

# Forecast the test set
forecast = model_fit.forecast(steps=len(test))

# Calculate accuracy
mae = mean_absolute_error(test, forecast)
print(f'Mean Absolute Error: {mae}')

# Combine the actual and predicted values for comparison
df_forecast = pd.DataFrame({'Actual': test, 'Forecast': forecast}, index=test.index)

print(df_forecast.head())


# Forecast the next day's average value
next_day_forecast = model_fit.forecast(steps=1)
print(f'Next Day Forecast: {next_day_forecast[0]}')



#######################
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error
import warnings

warnings.filterwarnings('ignore')

# Step 1: Load and Clean Data
def load_and_clean_data(filepath):
    # Load the CSV data with the correct header row
    df = pd.read_csv(filepath, skiprows=2)  # Adjust skiprows if needed
    df.columns = df.columns.str.strip()  # Remove any leading/trailing spaces in column names
    
    # Convert the 'Interval' column to datetime format
    df['Interval'] = pd.to_datetime(df['Interval'], errors='coerce')
    
    # Drop rows with missing 'Interval' values (if any)
    df.dropna(subset=['Interval'], inplace=True)
    
    # Set 'Interval' as the index
    df.set_index('Interval', inplace=True)
    
    # Sort the data by 'Interval'
    df.sort_index(inplace=True)
    
    # Handle any other missing values (optional: forward fill, backward fill, or drop)
    df.fillna(method='ffill', inplace=True)
    
    return df

# Step 2: Train and Forecast
def train_and_forecast(df, target_column='Average', forecast_days=1):
    # Use the target column for time series prediction
    series = df[target_column]
    
    # Split the data into training and testing sets
    train_size = int(len(series) * 0.8)
    train, test = series[:train_size], series[train_size:]
    
    # Fit the ARIMA model (order can be tuned based on ACF/PACF analysis)
    model = ARIMA(train, order=(5, 1, 0))
    model_fit = model.fit()
    
    # Forecast the test set
    forecast = model_fit.predict(start=len(train), end=len(train)+len(test)-1, dynamic=False)
    
    # Calculate accuracy using Mean Absolute Error (MAE)
    mae = mean_absolute_error(test, forecast)
    print(f'Mean Absolute Error: {mae}')
    
    # Combine the actual and predicted values for comparison
    df_forecast = pd.DataFrame({'Actual': test, 'Forecast': forecast}, index=test.index)
    print(df_forecast.head())
    
    # Forecast the next 'forecast_days' days
    future_forecast = model_fit.forecast(steps=forecast_days)
    print(f'Next {forecast_days} Day(s) Forecast: {future_forecast}')
    
    return df_forecast, future_forecast

# Step 3: Execution
filepath = 'your_filtered_data.csv'  # Replace with your actual file path
df = load_and_clean_data(filepath)
df_forecast, future_forecast = train_and_forecast(df, target_column='Average', forecast_days=1)

# Optional: Save the forecast results to a CSV file
df_forecast.to_csv('forecast_results.csv')

###################################################

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error
from statsmodels.tsa.stattools import adfuller

# Load and clean data
df = pd.read_csv('your_data.csv', skiprows=3)  # Adjust if the header row is not in the first line
df = df[['Rule', 'Interval', 'Average', 'Max', 'Min', 'StandardDeviation']]
df['Interval'] = pd.to_datetime(df['Interval'])
df = df.sort_values('Interval')

# Separate CPU and Memory data
cpu_data = df[df['Rule'].str.contains('processor', case=False)]
memory_data = df[df['Rule'].str.contains('memory', case=False)]

def test_stationarity(timeseries):
    # Perform Augmented Dickey-Fuller test:
    adf_test = adfuller(timeseries, autolag='AIC')
    p_value = adf_test[1]
    print(f'ADF Test p-value: {p_value}')
    return p_value < 0.05

def forecast_and_plot(data, title):
    # Test for stationarity
    if not test_stationarity(data['Average']):
        data['Average'] = data['Average'].diff().dropna()
        print(f'{title} data differenced to achieve stationarity')

    # Train ARIMA model
    try:
        model = ARIMA(data['Average'], order=(5, 1, 0))
        model_fit = model.fit()

        # Forecast the next day
        forecast = model_fit.forecast(steps=1)[0]
        
        # Calculate MAE
        predictions = model_fit.predict(start=0, end=len(data) - 1, dynamic=False)
        mae = mean_absolute_error(data['Average'], predictions)
        print(f'Mean Absolute Error: {mae}')

        # Plot actual vs forecast
        plt.figure(figsize=(10, 6))
        plt.plot(data['Interval'], data['Average'], label='Actual')
        plt.plot(data['Interval'], predictions, color='red', label='Forecast')
        plt.title(f'{title} Usage: Actual vs Forecast')
        plt.xlabel('Date')
        plt.ylabel('Usage')
        plt.legend()
        plt.show()

        print(f'Next Day Forecast: {forecast}')

    except Exception as e:
        print(f'Error with ARIMA model: {e}')
        print('Falling back to moving average model.')
        
        # Fallback: Simple Moving Average
        moving_avg = data['Average'].rolling(window=3).mean().dropna()
        forecast = moving_avg.iloc[-1]
        print(f'Next Day Forecast (Moving Avg): {forecast}')
        plt.figure(figsize=(10, 6))
        plt.plot(data['Interval'], data['Average'], label='Actual')
        plt.plot(data['Interval'][2:], moving_avg, color='red', label='Moving Average')
        plt.title(f'{title} Usage: Actual vs Moving Average')
        plt.xlabel('Date')
        plt.ylabel('Usage')
        plt.legend()
        plt.show()

# Forecast and plot for CPU
forecast_and_plot(cpu_data, 'CPU')

# Forecast and plot for Memory
forecast_and_plot(memory_data, 'Memory')


