import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Step 1: Load the Cleaned Data
cleaned_data = pd.read_csv('cleaned_data.csv')

# Convert 'Interval' to datetime format
cleaned_data['Interval'] = pd.to_datetime(cleaned_data['Interval'])
cleaned_data.set_index('Interval', inplace=True)

# Remove duplicates by keeping the last occurrence
cleaned_data = cleaned_data[~cleaned_data.index.duplicated(keep='last')]

# Set frequency to daily
cleaned_data = cleaned_data.asfreq('D')  # Set frequency to daily, adjust if needed


# Step 2: Combine CPU and Memory Data
try:
    # Ensure 'Rule' column has no missing values
    cleaned_data = cleaned_data.dropna(subset=['Rule'])
    
    # Filter CPU and Memory Data
    cpu_data = cleaned_data[cleaned_data['Rule'].str.contains('Processor', na=False)]
    memory_data = cleaned_data[cleaned_data['Rule'].str.contains('Memory', na=False)]

    # Ensure data is not empty
    if cpu_data.empty or memory_data.empty:
        raise ValueError("Filtered data is empty. Check if the 'Rule' column contains expected values.")

    # Remove duplicates and set frequency
    cpu_data = cpu_data[~cpu_data.index.duplicated(keep='last')]
    memory_data = memory_data[~memory_data.index.duplicated(keep='last')]

    # Combine data into a single DataFrame
    combined_data = pd.DataFrame({
        'CPU_Average': cpu_data['Average'],
        'Memory_Average': memory_data['Average']
    }).dropna()

    print("Combined data:")
    print(combined_data.head())

except Exception as e:
    print(f"Error in combining CPU and Memory data: {e}")

# Step 3: Split Data into Training and Testing Sets
train_size = int(len(combined_data) * 0.8)
train_data = combined_data[:train_size]
test_data = combined_data[train_size:]

# Step 4: Train and Test the ARIMA Model for CPU Usage
try:
    cpu_model = ARIMA(train_data['CPU_Average'].dropna(), order=(5, 1, 0))
    cpu_model_fit = cpu_model.fit()
    cpu_forecast = cpu_model_fit.forecast(steps=len(test_data))
    print("CPU forecast successful.")
except Exception as e:
    print(f"Error in CPU forecasting: {e}")

# Step 5: Calculate accuracy for CPU
try:
    cpu_mae = mean_absolute_error(test_data['CPU_Average'], cpu_forecast)
    cpu_rmse = mean_squared_error(test_data['CPU_Average'], cpu_forecast, squared=False)
    print(f'CPU Usage MAE: {cpu_mae:.2f}')
    print(f'CPU Usage RMSE: {cpu_rmse:.2f}')
except Exception as e:
    print(f"Error in CPU accuracy calculation: {e}")

# Step 6: Train and Test the ARIMA Model for Memory Usage
try:
    memory_model = ARIMA(train_data['Memory_Average'].dropna(), order=(5, 1, 0))
    memory_model_fit = memory_model.fit()
    memory_forecast = memory_model_fit.forecast(steps=len(test_data))
    print("Memory forecast successful.")
except Exception as e:
    print(f"Error in Memory forecasting: {e}")

# Step 7: Calculate accuracy for Memory
try:
    memory_mae = mean_absolute_error(test_data['Memory_Average'], memory_forecast)
    memory_rmse = mean_squared_error(test_data['Memory_Average'], memory_forecast, squared=False)
    print(f'Memory Usage MAE: {memory_mae:.2f}')
    print(f'Memory Usage RMSE: {memory_rmse:.2f}')
except Exception as e:
    print(f"Error in Memory accuracy calculation: {e}")

# Step 8: Visualization
plt.figure(figsize=(14, 7))
plt.plot(test_data.index, test_data['CPU_Average'], label='Actual CPU Usage')
plt.plot(test_data.index, cpu_forecast, label='Forecasted CPU Usage', linestyle='--')
plt.plot(test_data.index, test_data['Memory_Average'], label='Actual Memory Usage')
plt.plot(test_data.index, memory_forecast, label='Forecasted Memory Usage', linestyle='--')
plt.title('Actual vs Forecasted CPU and Memory Usage')
plt.xlabel('Date')
plt.ylabel('Usage (%)')
plt.legend()
plt.show()
###########################

import pandas as pd
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error
import matplotlib.pyplot as plt

# Load the data
df = pd.read_csv('your_file.csv')

# Ensure 'Interval' is in datetime format
df['Interval'] = pd.to_datetime(df['Interval'])

# Filter for CPU and Memory usage (adjust based on your actual metric names)
cpu_df = df[df['Rule'].str.contains('cpu', case=False)]
memory_df = df[df['Rule'].str.contains('memory', case=False)]

# Function to prepare data for Prophet
def prepare_data(dataframe):
    # Rename columns for Prophet
    prophet_df = dataframe[['Interval', 'Average']].rename(columns={'Interval': 'ds', 'Average': 'y'})
    return prophet_df

# Prepare data for forecasting
cpu_prophet_df = prepare_data(cpu_df)
memory_prophet_df = prepare_data(memory_df)

# Initialize Prophet model
model = Prophet()

# Fit the model
model.fit(cpu_prophet_df)
model.fit(memory_prophet_df)

# Create a dataframe for future dates
future_cpu = model.make_future_dataframe(periods=30)  # Forecast for the next 30 days
future_memory = model.make_future_dataframe(periods=30)

# Forecast the future values
forecast_cpu = model.predict(future_cpu)
forecast_memory = model.predict(future_memory)

# Evaluate model accuracy on historical data
y_true_cpu = cpu_prophet_df['y'].values
y_pred_cpu = model.predict(cpu_prophet_df)['yhat'].values

y_true_memory = memory_prophet_df['y'].values
y_pred_memory = model.predict(memory_prophet_df)['yhat'].values

mae_cpu = mean_absolute_error(y_true_cpu, y_pred_cpu)
mae_memory = mean_absolute_error(y_true_memory, y_pred_memory)

print(f'Mean Absolute Error (CPU): {mae_cpu}')
print(f'Mean Absolute Error (Memory): {mae_memory}')

# Plot the forecast
model.plot(forecast_cpu)
plt.title('CPU Usage Forecast')
plt.show()

model.plot(forecast_memory)
plt.title('Memory Usage Forecast')
plt.show()
