import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Step 1: Load the Cleaned Data
cleaned_data = pd.read_csv('cleaned_data.csv')

# Convert 'Interval' to datetime format
cleaned_data['Interval'] = pd.to_datetime(cleaned_data['Interval'])
cleaned_data.set_index('Interval', inplace=True)

# Remove duplicates by keeping the last occurrence
cleaned_data = cleaned_data[~cleaned_data.index.duplicated(keep='last')]

# Set frequency to daily
cleaned_data = cleaned_data.asfreq('D')  # Set frequency to daily, adjust if needed


# Step 2: Combine CPU and Memory Data
try:
    # Ensure 'Rule' column has no missing values
    cleaned_data = cleaned_data.dropna(subset=['Rule'])
    
    # Filter CPU and Memory Data
    cpu_data = cleaned_data[cleaned_data['Rule'].str.contains('Processor', na=False)]
    memory_data = cleaned_data[cleaned_data['Rule'].str.contains('Memory', na=False)]

    # Ensure data is not empty
    if cpu_data.empty or memory_data.empty:
        raise ValueError("Filtered data is empty. Check if the 'Rule' column contains expected values.")

    # Remove duplicates and set frequency
    cpu_data = cpu_data[~cpu_data.index.duplicated(keep='last')]
    memory_data = memory_data[~memory_data.index.duplicated(keep='last')]

    # Combine data into a single DataFrame
    combined_data = pd.DataFrame({
        'CPU_Average': cpu_data['Average'],
        'Memory_Average': memory_data['Average']
    }).dropna()

    print("Combined data:")
    print(combined_data.head())

except Exception as e:
    print(f"Error in combining CPU and Memory data: {e}")

# Step 3: Split Data into Training and Testing Sets
train_size = int(len(combined_data) * 0.8)
train_data = combined_data[:train_size]
test_data = combined_data[train_size:]

# Step 4: Train and Test the ARIMA Model for CPU Usage
try:
    cpu_model = ARIMA(train_data['CPU_Average'].dropna(), order=(5, 1, 0))
    cpu_model_fit = cpu_model.fit()
    cpu_forecast = cpu_model_fit.forecast(steps=len(test_data))
    print("CPU forecast successful.")
except Exception as e:
    print(f"Error in CPU forecasting: {e}")

# Step 5: Calculate accuracy for CPU
try:
    cpu_mae = mean_absolute_error(test_data['CPU_Average'], cpu_forecast)
    cpu_rmse = mean_squared_error(test_data['CPU_Average'], cpu_forecast, squared=False)
    print(f'CPU Usage MAE: {cpu_mae:.2f}')
    print(f'CPU Usage RMSE: {cpu_rmse:.2f}')
except Exception as e:
    print(f"Error in CPU accuracy calculation: {e}")

# Step 6: Train and Test the ARIMA Model for Memory Usage
try:
    memory_model = ARIMA(train_data['Memory_Average'].dropna(), order=(5, 1, 0))
    memory_model_fit = memory_model.fit()
    memory_forecast = memory_model_fit.forecast(steps=len(test_data))
    print("Memory forecast successful.")
except Exception as e:
    print(f"Error in Memory forecasting: {e}")

# Step 7: Calculate accuracy for Memory
try:
    memory_mae = mean_absolute_error(test_data['Memory_Average'], memory_forecast)
    memory_rmse = mean_squared_error(test_data['Memory_Average'], memory_forecast, squared=False)
    print(f'Memory Usage MAE: {memory_mae:.2f}')
    print(f'Memory Usage RMSE: {memory_rmse:.2f}')
except Exception as e:
    print(f"Error in Memory accuracy calculation: {e}")

# Step 8: Visualization
plt.figure(figsize=(14, 7))
plt.plot(test_data.index, test_data['CPU_Average'], label='Actual CPU Usage')
plt.plot(test_data.index, cpu_forecast, label='Forecasted CPU Usage', linestyle='--')
plt.plot(test_data.index, test_data['Memory_Average'], label='Actual Memory Usage')
plt.plot(test_data.index, memory_forecast, label='Forecasted Memory Usage', linestyle='--')
plt.title('Actual vs Forecasted CPU and Memory Usage')
plt.xlabel('Date')
plt.ylabel('Usage (%)')
plt.legend()
plt.show()
###########################

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error

# Load the data
df = pd.read_csv('your_file.csv')

# Ensure 'Interval' is in datetime format
df['Interval'] = pd.to_datetime(df['Interval'])

# Filter for CPU and Memory usage (adjust based on your actual metric names)
cpu_df = df[df['Rule'].str.contains('cpu', case=False)]
memory_df = df[df['Rule'].str.contains('memory', case=False)]

# Function to prepare and forecast data
def forecast_arima(dataframe, label, order=(5, 1, 0), steps=30):
    # Prepare data
    dataframe = dataframe.copy()
    dataframe.set_index('Interval', inplace=True)
    
    # Fit ARIMA model
    model = ARIMA(dataframe['Average'], order=order)
    model_fit = model.fit()
    
    # Forecast
    forecast = model_fit.forecast(steps=steps)
    
    # Create future dates for plotting
    future_dates = pd.date_range(start=dataframe.index[-1] + pd.Timedelta(days=1), periods=steps, freq='D')
    
    # Plot the forecast
    plt.figure(figsize=(10, 5))
    plt.plot(dataframe.index, dataframe['Average'], label='Observed')
    plt.plot(future_dates, forecast, label='Forecast')
    plt.legend()
    plt.title(f'{label} Usage Forecast')
    plt.xlabel('Date')
    plt.ylabel('Average')
    plt.show()
    
    # Evaluate model accuracy on historical data
    y_true = dataframe['Average']
    y_pred = model_fit.predict(start=0, end=len(dataframe)-1)
    mae = mean_absolute_error(y_true, y_pred)
    print(f'Mean Absolute Error ({label}): {mae}')

# Forecast for CPU
print("CPU Forecast:")
forecast_arima(cpu_df, label='CPU')

# Forecast for Memory
print("Memory Forecast:")
forecast_arima(memory_df, label='Memory')

