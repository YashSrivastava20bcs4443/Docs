# Function to run PowerShell command on a remote machine
function Run-PowerShellCommand {
    param (
        [string]$AssetName,
        [string]$Command
    )

    Write-Host "Running command on ${AssetName}: $Command"
    $sessionCommand = Invoke-Command -ComputerName $AssetName -ScriptBlock {Invoke-Expression $using:Command}
    return $sessionCommand
}

# Function to get SentinelOne version
function Get-SentinelOneVersion {
    param (
        [string]$AssetName
    )

    $sentinelFolder = Run-PowerShellCommand -AssetName $AssetName -Command '(Get-ChildItem "C:\Program Files\SentinelOne" | Where-Object { $_.PSIsContainer }).FullName'
    
    if ($sentinelFolder) {
        $sentinelVersion = Run-PowerShellCommand -AssetName $AssetName -Command "(Get-Item '$sentinelFolder\SentinelAgent.exe').VersionInfo.ProductVersion"
        return $sentinelVersion.Trim()
    } else {
        return "SentinelOne folder not found"
    }
}

# Function to check for security patches
function Check-SecurityPatches {
    param (
        [string]$AssetName
    )

    $securityPatchesCommand = 'Get-WmiObject -Class win32_quickfixengineering'
    $output = Run-PowerShellCommand -AssetName $AssetName -Command $securityPatchesCommand

    if (-not $output) {
        return "No Security Patches Found"
    }

    $patchLines = $output -split "`n"
    $securityUpdates = @()
    $dateRegex = '(\d{1,2}[/-]\d{1,2}[/-]\d{4})'
    $hotfixRegex = '(KB\d{7})'

    foreach ($line in $patchLines) {
        if ($line -match "Security Update") {
            $dateMatch = [regex]::Match($line, $dateRegex)
            $hotfixMatch = [regex]::Match($line, $hotfixRegex)

            if ($dateMatch.Success -and $hotfixMatch.Success) {
                $installedOnStr = $dateMatch.Value
                $hotfixId = $hotfixMatch.Value
                try {
                    $installedOnDate = [datetime]::ParseExact($installedOnStr, "dd-MM-yyyy", $null)
                    $securityUpdates += [pscustomobject]@{
                        InstalledOn = $installedOnDate
                        HotfixID = $hotfixId
                    }
                } catch {
                    continue
                }
            }
        }
    }

    if ($securityUpdates.Count -gt 0) {
        $latestUpdate = $securityUpdates | Sort-Object InstalledOn -Descending | Select-Object -First 1
        return "Latest Security Patch Installed On: $($latestUpdate.InstalledOn.ToString('dd-MM-yyyy')) (HotFixID: $($latestUpdate.HotfixID))"
    } else {
        return "No Security Updates Found"
    }
}

# Function to check NTP configuration
function Check-NTP {
    param (
        [string]$AssetName
    )

    $ntpCommand = 'w32tm /query /status'
    $output = Run-PowerShellCommand -AssetName $AssetName -Command $ntpCommand

    if ($output -match "Source") {
        $ntpSource = ($output -split "Source: ")[1] -split "`n" | Select-Object -First 1
        return $ntpSource
    } else {
        return "NTP Not Configured"
    }
}

# Function to check Windows compliance
function Check-ComplianceWindows {
    param (
        [string]$AssetName
    )

    $compliance = @{}

    # OS information
    $osInfo = Run-PowerShellCommand -AssetName $AssetName -Command '(Get-WmiObject -Class Win32_OperatingSystem).Caption'
    $compliance["OS"] = $osInfo.Trim()

    # SentinelOne status
    $sentinelStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'Get-Service -Name "SentinelAgent"'
    if ($sentinelStatus -match "Running") {
        $sentinelVersion = Get-SentinelOneVersion -AssetName $AssetName
        $compliance["SentinelOne"] = "Running (Version: $sentinelVersion)"
    } else {
        $compliance["SentinelOne"] = "Not Installed or Not Running"
    }

    # Security patches
    $compliance["Patches"] = Check-SecurityPatches -AssetName $AssetName

    # NTP configuration
    $compliance["NTP"] = Check-NTP -AssetName $AssetName

    # Windows activation status
    $activationStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'powershell "Get-CimInstance -ClassName SoftwareLicensingProduct | Where-Object { $_.PartialProductKey } | Select-Object LicenseStatus"'
    if ($activationStatus -match "1") {
        $compliance["WindowsActivation"] = "Activated"
    } else {
        $compliance["WindowsActivation"] = "Not Activated"
    }

    # WinCollect status
    $wincollectStatus = Run-PowerShellCommand -AssetName $AssetName -Command 'Get-Service -Name "WinCollect"'
    $compliance["WinCollect"] = $wincollectStatus.Trim()

    return $compliance
}

# Function to read hostnames from a text file
function Read-Hostnames {
    param (
        [string]$FilePath
    )
    return Get-Content -Path $FilePath
}

# Main function
function Main {
    $hostnameFilePath = "D:\VS CODE\python\comp\hostnames.txt"
    $csvFilePath = "D:\VS CODE\python\comp\compliance_report.csv"
    $hostnames = Read-Hostnames -FilePath $hostnameFilePath

    # Create CSV file and write header
    $header = "Hostname,OS,SentinelOne,Patches,NTP,WindowsActivation,WinCollect"
    Set-Content -Path $csvFilePath -Value $header

    foreach ($assetName in $hostnames) {
        Write-Host "Checking $assetName..."
        $complianceResults = Check-ComplianceWindows -AssetName $assetName

        # Prepare row data
        $rowData = "$assetName," + ($complianceResults["OS"]) + "," + ($complianceResults["SentinelOne"]) + "," +
                   ($complianceResults["Patches"]) + "," + ($complianceResults["NTP"]) + "," +
                   ($complianceResults["WindowsActivation"]) + "," + ($complianceResults["WinCollect"])

        # Append row data to CSV
        Add-Content -Path $csvFilePath -Value $rowData
    }

    Write-Host "Compliance report generated successfully at $csvFilePath."
}

# Run the script
Main
