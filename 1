Below is a Python script that accomplishes your request: it connects to Linux and Windows VMs via SSH and PowerShell Remoting (WinRM), checks the installed software versions against specified versions, compares them with software in an Azure Blob Storage container, generates a report, and emails it using SMTP. Iâ€™ve also included standard commands to manually check software versions and statuses on both Linux and Windows systems.

---

### Python Script: `vm_software_checker.py`

```python
import paramiko
import winrm
import azure.storage.blob as blob
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import os

# Configuration
LINUX_VMS = ["192.168.1.10", "192.168.1.11"]  # Replace with your Linux VM IPs
WINDOWS_VMS = ["192.168.1.20", "192.168.1.21"]  # Replace with your Windows VM IPs
AZURE_STORAGE_CONNECTION_STRING = "your_azure_storage_connection_string"  # Replace with your connection string
CONTAINER_NAME = "software-container"  # Replace with your container name
SSH_USER = "your_linux_username"  # Replace with SSH username
SSH_PASSWORD = "your_linux_password"  # Replace with SSH password or use key
WINRM_USER = "your_windows_username"  # Replace with Windows username
WINRM_PASSWORD = "your_windows_password"  # Replace with Windows password
SMTP_SERVER = "smtp.gmail.com"  # Replace with your SMTP server
SMTP_PORT = 587
SMTP_USER = "your_email@gmail.com"  # Replace with your email
SMTP_PASSWORD = "your_app_specific_password"  # Replace with your password or app-specific password
TO_EMAILS = ["team1@example.com", "team2@example.com"]  # Replace with recipient emails
CC_EMAILS = ["manager@example.com"]  # Replace with CC emails

# Expected software versions
EXPECTED_LINUX_SOFTWARE = {
    "node_exporter": "1.9.0",
    "SentinelAgent": "24.2.2.20",
    "nfs-common": "installed"  # Just check presence
}
EXPECTED_WINDOWS_SOFTWARE = {
    "windows_exporter": "0.26.1",
    "SentinelInstaller": "24.1.5.277",
    "wincollect": "10.1.3-24"
}

# Commands to check versions
LINUX_COMMANDS = {
    "node_exporter": "node_exporter --version 2>&1 | grep -oP 'version \K\S+' || echo 'Not Installed'",
    "SentinelAgent": "dpkg -l | grep sentinelagent | awk '{print $3}' || echo 'Not Installed'",
    "nfs-common": "dpkg -l | grep nfs-common | awk '{print $3}' || echo 'Not Installed'"
}

WINDOWS_COMMANDS = {
    "windows_exporter": "wmic product where \"Name like '%windows_exporter%'\" get Version | findstr /r \"^[0-9]\"",
    "SentinelInstaller": "wmic product where \"Name like '%Sentinel%'\" get Version | findstr /r \"^[0-9]\"",
    "wincollect": "wmic product where \"Name like '%wincollect%'\" get Version | findstr /r \"^[0-9]\""
}

# Function to check Linux VM
def check_linux_vm(ip):
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        ssh.connect(ip, username=SSH_USER, password=SSH_PASSWORD)
        result = {}
        for software, cmd in LINUX_COMMANDS.items():
            stdin, stdout, stderr = ssh.exec_command(cmd)
            version = stdout.read().decode().strip() or "Not Installed"
            result[software] = version
        # Check additional configurations
        stdin, stdout, stderr = ssh.exec_command("cat /etc/passwd | grep -v 'nologin\\|false' | wc -l")
        users = int(stdout.read().decode().strip()) - 1  # Subtract root
        result["additional_users"] = users > 0
        stdin, stdout, stderr = ssh.exec_command("ufw status | grep -q 'inactive' && echo 'Disabled' || echo 'Active'")
        result["firewall"] = stdout.read().decode().strip()
        stdin, stdout, stderr = ssh.exec_command("cat /etc/rsyslog.conf | grep -q '^*.* @' && echo 'Configured' || echo 'Not Configured'")
        result["syslog"] = stdout.read().decode().strip()
        ssh.close()
        return result
    except Exception as e:
        return {"error": str(e)}

# Function to check Windows VM
def check_windows_vm(ip):
    session = winrm.Session(f"http://{ip}:5985/wsman", auth=(WINRM_USER, WINRM_PASSWORD))
    try:
        result = {}
        for software, cmd in WINDOWS_COMMANDS.items():
            response = session.run_cmd("powershell", ["-Command", cmd])
            version = response.std_out.decode().strip() or "Not Installed"
            result[software] = version
        return result
    except Exception as e:
        return {"error": str(e)}

# Function to check Azure Blob Storage
def check_blob_storage():
    blob_service_client = blob.BlobServiceClient.from_connection_string(AZURE_STORAGE_CONNECTION_STRING)
    container_client = blob_service_client.get_container_client(CONTAINER_NAME)
    blobs = container_client.list_blobs()
    blob_versions = {}
    for b in blobs:
        name = b.name
        if "node_exporter" in name:
            blob_versions["node_exporter"] = name.split("-")[1]
        elif "SentinelAgent_linux" in name:
            blob_versions["SentinelAgent"] = name.split("_v")[1].replace(".deb", "")
        elif "windows_exporter" in name:
            blob_versions["windows_exporter"] = name.split("-")[1].replace("-amd64.msi", "")
        elif "SentinelInstaller" in name:
            blob_versions["SentinelInstaller"] = name.split("_v")[1].replace(".msi", "")
        elif "wincollect" in name:
            blob_versions["wincollect"] = name.split("-")[1].replace(".msi", "")
    return blob_versions

# Generate report
def generate_report(linux_results, windows_results, blob_versions):
    report = f"Software Version Comparison Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    
    report += "## Linux VMs\n"
    for ip, result in linux_results.items():
        report += f"VM IP: {ip}\n"
        if "error" in result:
            report += f"  Error: {result['error']}\n"
        else:
            for sw, ver in result.items():
                expected = EXPECTED_LINUX_SOFTWARE.get(sw, "N/A")
                report += f"  {sw}: {ver} (Expected: {expected}, Blob: {blob_versions.get(sw, 'N/A')})\n"
        report += "\n"
    
    report += "## Windows VMs\n"
    for ip, result in windows_results.items():
        report += f"VM IP: {ip}\n"
        if "error" in result:
            report += f"  Error: {result['error']}\n"
        else:
            for sw, ver in result.items():
                expected = EXPECTED_WINDOWS_SOFTWARE.get(sw, "N/A")
                report += f"  {sw}: {ver} (Expected: {expected}, Blob: {blob_versions.get(sw, 'N/A')})\n"
        report += "\n"
    
    return report

# Send email
def send_email(report):
    msg = MIMEMultipart()
    msg['From'] = SMTP_USER
    msg['To'] = ", ".join(TO_EMAILS)
    msg['Cc'] = ", ".join(CC_EMAILS)
    msg['Subject'] = "VM Software Version Comparison Report"
    msg.attach(MIMEText(report, 'plain'))
    
    with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
        server.starttls()
        server.login(SMTP_USER, SMTP_PASSWORD)
        server.sendmail(SMTP_USER, TO_EMAILS + CC_EMAILS, msg.as_string())

# Main execution
def main():
    linux_results = {ip: check_linux_vm(ip) for ip in LINUX_VMS}
    windows_results = {ip: check_windows_vm(ip) for ip in WINDOWS_VMS}
    blob_versions = check_blob_storage()
    report = generate_report(linux_results, windows_results, blob_versions)
    print(report)  # For debugging
    send_email(report)
    with open("software_comparison_report.txt", "w") as f:
        f.write(report)

if __name__ == "__main__":
    main()
```

---

### Prerequisites
1. **Install Python Libraries**:
   ```bash
   pip install paramiko pywinrm azure-storage-blob
   ```
2. **Configure VMs**:
   - Linux: Enable SSH (port 22) and ensure `SSH_USER`/`SSH_PASSWORD` or key-based auth works.
   - Windows: Enable WinRM (port 5985) with `winrm quickconfig` and allow basic auth (`Set-Item -Path WSMan:\localhost\Service\Auth\Basic -Value $true`).
3. **Azure Blob Storage**: Ensure the container has the software files with versions in filenames.
4. **SMTP**: Use an app-specific password for Gmail or configure your SMTP server.

---

### Manual Commands to Check Software Versions and Status
#### Linux VMs
- **node_exporter**:
  ```bash
  node_exporter --version 2>&1 | grep "version" || echo "Not Installed"
  ```
- **SentinelAgent**:
  ```bash
  dpkg -l | grep sentinelagent || echo "Not Installed"
  ```
- **nfs-common**:
  ```bash
  dpkg -l | grep nfs-common || echo "Not Installed"
  ```
- **Users**:
  ```bash
  cat /etc/passwd | grep -v "nologin\|false"  # List active users
  ```
- **Firewall**:
  ```bash
  ufw status  # Check if inactive
  ```
- **Syslog**:
  ```bash
  cat /etc/rsyslog.conf | grep "*.* @"  # Check for remote syslog config
  ```

#### Windows VMs
- **windows_exporter**:
  ```cmd
  wmic product where "Name like '%windows_exporter%'" get Name,Version
  ```
- **SentinelInstaller**:
  ```cmd
  wmic product where "Name like '%Sentinel%'" get Name,Version
  ```
- **wincollect**:
  ```cmd
  wmic product where "Name like '%wincollect%'" get Name,Version
  ```

---

### How to Use the Script
1. **Update Configuration**:
   - Replace `LINUX_VMS` and `WINDOWS_VMS` with your VM IPs.
   - Set `AZURE_STORAGE_CONNECTION_STRING`, `CONTAINER_NAME`, credentials, and email details.
2. **Run the Script**:
   ```bash
   python vm_software_checker.py
   ```
3. **Output**:
   - A report (`software_comparison_report.txt`) is generated and emailed to `TO_EMAILS` with `CC_EMAILS` in CC.

---

### Report Sample
```
Software Version Comparison Report - 2025-04-03 10:00:00

## Linux VMs
VM IP: 192.168.1.10
  node_exporter: 1.9.0 (Expected: 1.9.0, Blob: 1.9.0)
  SentinelAgent: 24.2.2.20 (Expected: 24.2.2.20, Blob: 24.2.2.20)
  nfs-common: installed (Expected: installed, Blob: N/A)
  additional_users: True (Expected: N/A, Blob: N/A)
  firewall: Disabled (Expected: N/A, Blob: N/A)
  syslog: Configured (Expected: N/A, Blob: N/A)

## Windows VMs
VM IP: 192.168.1.20
  windows_exporter: 0.26.1 (Expected: 0.26.1, Blob: 0.26.1)
  SentinelInstaller: 24.1.5.277 (Expected: 24.1.5.277, Blob: 24.1.5.277)
  wincollect: 10.1.3-24 (Expected: 10.1.3-24, Blob: 10.1.3-24)
```

---

### Notes
- **Security**: Store credentials securely (e.g., environment variables or a secrets manager) instead of hardcoding.
- **Scalability**: For 1,200 VMs, split IP lists into batches or use a VM inventory file.
- **Error Handling**: The script logs errors; enhance it with retries if needed.

Let me know if you need adjustments or help with setup!
