

const pool = new Pool({
  user: DB_USER,
  host: DB_HOST,
  database: DB_NAME,
  password: DB_PASSWORD,
  port: DB_PORT,
});

// --- Function: initializeDatabase ---
// Creates the "contact_data" table if it does not already exist.
async function initializeDatabase() {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS contact_data (
        id SERIAL PRIMARY KEY,
        abandoned BOOLEAN,
        abandonSeconds BIGINT,
        acwSeconds BIGINT,
        agentId VARCHAR(50),
        agentSeconds BIGINT,
        analyticsProcessedDate TIMESTAMPTZ,
        callbackTime TIMESTAMPTZ,
        conferenceSeconds BIGINT,
        contactId VARCHAR(50),
        campaignId VARCHAR(50),
        campaignName VARCHAR(255),
        contactStartDate TIMESTAMPTZ,
        dateACWWarehoused TIMESTAMPTZ,
        dateContactWarehoused TIMESTAMPTZ,
        dispositionNotes TEXT,
        endReason VARCHAR(255),
        firstName VARCHAR(100),
        lastName VARCHAR(100),
        fromAddress VARCHAR(255),
        highProficiency BOOLEAN,
        holdCount BIGINT,
        holdSeconds BIGINT,
        inQueueSeconds BIGINT,
        isAnalyticsProcessed BOOLEAN,
        isLogged BOOLEAN,
        isOutbound BOOLEAN,
        isRefused BOOLEAN,
        isShortAbandon BOOLEAN,
        isTakeover BOOLEAN,
        lastUpdateTime TIMESTAMPTZ,
        lowProficiency BOOLEAN,
        masterContactId VARCHAR(50),
        mediaSubTypeId VARCHAR(50),
        mediaSubTypeName VARCHAR(255),
        mediaTypeId VARCHAR(50),
        mediaTypeName VARCHAR(255),
        pointOfContactId VARCHAR(50),
        pointOfContactName VARCHAR(255),
        postQueueSeconds BIGINT,
        preQueueSeconds BIGINT,
        primaryDispositionId VARCHAR(50),
        refuseTime TIMESTAMPTZ,
        releaseSeconds BIGINT,
        routingAttribute VARCHAR(255),
        routingTimeSecondary VARCHAR(255),
        DispositionId VARCHAR(50),
        serviceLevelFlag BOOLEAN,
        skillId VARCHAR(50),
        skillName VARCHAR(255),
        teamId VARCHAR(50),
        transferIndicatorId VARCHAR(50),
        transferIndicatorName VARCHAR(255),
        tags TEXT,
        refuseReason TEXT,
        teamName VARCHAR(255),
        toAddress VARCHAR(255),
        totalDurationSeconds BIGINT,
        createdAt TIMESTAMPTZ DEFAULT NOW()
      );
    `;
    await pool.query(createTableQuery);
    console.log("Database initialized â€“ 'contact_data' table is ready.");
  } catch (error) {
    console.error("Error initializing database:", error);
    throw error;
  }
}

// --- Function: getAccessToken ---
// Retrieves an access token from the external API.
async function getAccessToken() {
  try {
    const response = await axios.post(ACCESS_TOKEN_URL);
    console.log("Access token endpoint response:", response.data);
    if (response.data) {
      const token = response.data["access token"] || response.data.access_token;
      if (token) {
        console.log("Access token acquired:", token);
        return token;
      }
    }
    throw new Error("Access token missing from response.");
  } catch (error) {
    console.error("Error getting access token:", error);
    throw error;
  }
}

// --- Function: fetchAPIData ---
// Fetches raw data from the external API for the past hour with pagination.
async function fetchAPIData() {
  try {
    const token = await getAccessToken();
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };

    const endDate = new Date().toISOString();
    const startDate = new Date(Date.now() - 60 * 60 * 1000).toISOString();

    let allRecords = [];
    let skip = 0;
    const top = 10000;

    while (true) {
      const params = {
        startdate: startDate,
        enddate: endDate,
        top: top,
        skip: skip
      };

      console.log(`Fetching records with skip = ${skip}`);
      const response = await axios.get(API_URL, { headers, params });
      const records = response.data?.completedContacts;
      console.log(`Fetched ${records ? records.length : 0} records for this batch.`);
      if (records && records.length > 0) {
        allRecords = allRecords.concat(records);
        skip += top;
        if (records.length < top) break;
      } else {
        break;
      }
    }
    console.log(`Total records fetched: ${allRecords.length}`);
    return allRecords;
  } catch (error) {
    console.error("Error fetching API data:", error);
    return [];
  }
}

// --- Helper: convertToEST ---
// Converts a given date value to Eastern Standard Time (EST).
function convertToEST(dateValue) {
  if (!dateValue) return null;
  return moment.tz(dateValue, 'America/New_York').format();
}

// --- Function: insertData ---
// Inserts the raw records into the PostgreSQL database.
async function insertData(records) {
  if (!records || records.length === 0) {
    console.log("No records to insert.");
    return;
  }
  let insertedCount = 0;
  for (const record of records) {
    // Convert date/time fields to EST.
    const dateFields = [
      'analyticsProcessedDate',
      'callbackTime',
      'contactStartDate',
      'dateACWWarehoused',
      'dateContactWarehoused',
      'lastUpdateTime',
      'refuseTime'
    ];
    dateFields.forEach(field => {
      if (record[field]) {
        record[field] = convertToEST(record[field]);
      }
    });

    const query = `
      INSERT INTO contact_data (
        abandoned, abandonSeconds, acwSeconds, agentId, agentSeconds,
        analyticsProcessedDate, callbackTime, conferenceSeconds, contactId,
        campaignId, campaignName, contactStartDate, dateACWWarehoused,
        dateContactWarehoused, dispositionNotes, endReason, firstName,
        lastName, fromAddress, highProficiency, holdCount, holdSeconds,
        inQueueSeconds, isAnalyticsProcessed, isLogged, isOutbound, isRefused,
        isShortAbandon, isTakeover, lastUpdateTime, lowProficiency,
        masterContactId, mediaSubTypeId, mediaSubTypeName, mediaTypeId,
        mediaTypeName, pointOfContactId, pointOfContactName, postQueueSeconds,
        preQueueSeconds, primaryDispositionId, refuseTime, releaseSeconds,
        routingAttribute, routingTimeSecondary, DispositionId, serviceLevelFlag,
        skillId, skillName, teamId, transferIndicatorId, transferIndicatorName,
        tags, refuseReason, teamName, toAddress, totalDurationSeconds
      )
      VALUES (
        $1, $2, $3, $4, $5,
        $6, $7, $8, $9, $10,
        $11, $12, $13, $14, $15,
        $16, $17, $18, $19, $20,
        $21, $22, $23, $24, $25,
        $26, $27, $28, $29, $30,
        $31, $32, $33, $34, $35,
        $36, $37, $38, $39, $40,
        $41, $42, $43, $44, $45,
        $46, $47, $48, $49, $50,
        $51, $52, $53, $54, $55,
        $56, $57
      )
    `;
    const values = [
      record.abandoned,               // 1
      record.abandonSeconds,          // 2
      record.acwSeconds,              // 3
      record.agentId,                 // 4
      record.agentSeconds,            // 5
      record.analyticsProcessedDate,  // 6
      record.callbackTime,            // 7
      record.conferenceSeconds,       // 8
      record.contactId,               // 9
      record.campaignId,              // 10
      record.campaignName,            // 11
      record.contactStartDate,        // 12
      record.dateACWWarehoused,       // 13
      record.dateContactWarehoused,   // 14
      record.dispositionNotes,        // 15
      record.endReason,               // 16
      record.firstName,               // 17
      record.lastName,                // 18
      record.fromAddress,             // 19
      record.highProficiency,         // 20
      record.holdCount,               // 21
      record.holdSeconds,             // 22
      record.inQueueSeconds,          // 23
      record.isAnalyticsProcessed,    // 24
      record.isLogged,                // 25
      record.isOutbound,              // 26
      record.isRefused,               // 27
      record.isShortAbandon,          // 28
      record.isTakeover,              // 29
      record.lastUpdateTime,          // 30
      record.lowProficiency,          // 31
      record.masterContactId,         // 32
      record.mediaSubTypeId,          // 33
      record.mediaSubTypeName,        // 34
      record.mediaTypeId,             // 35
      record.mediaTypeName,           // 36
      record.pointOfContactId,        // 37
      record.pointOfContactName,      // 38
      record.postQueueSeconds,        // 39
      record.preQueueSeconds,         // 40
      record.primaryDispositionId,    // 41
      record.refuseTime,              // 42
      record.releaseSeconds,          // 43
      record.routingAttribute,        // 44
      record.routingTimeSecondary,    // 45
      record.DispositionId,           // 46
      record.serviceLevelFlag,        // 47
      record.skillId,                 // 48
      record.skillName,               // 49
      record.teamId,                  // 50
      record.transferIndicatorId,     // 51
      record.transferIndicatorName,   // 52
      record.tags,                    // 53
      record.refuseReason,            // 54
      record.teamName,                // 55
      record.toAddress,               // 56
      record.totalDurationSeconds     // 57
    ];

    try {
      await pool.query(query, values);
      insertedCount++;
    } catch (error) {
      console.error("Error inserting record:", error);
    }
  }
  console.log(`Inserted ${insertedCount} records into the database.`);
}

// --- Function: fetchAndDump ---
// Fetches data from the API and inserts it into the database.
async function fetchAndDump() {
  console.log("Starting data ingestion process...");
  const records = await fetchAPIData();
  console.log("Records fetched:", records.length);
  await insertData(records);
}

// --- Function: initialize ---
// Ensures the table exists before running ingestion.
async function initialize() {
  await initializeDatabase();
}

// --- Main Execution ---
(async () => {
  try {
    console.log("Starting initialization...");
    await initialize();
    console.log("Initialization complete. Fetching and inserting data...");
    await fetchAndDump();
    console.log("Data ingestion process complete.");
  } catch (error) {
    console.error("Error in main execution:", error);
  } finally {
    await pool.end();
  }
})();
