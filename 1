# Function to get SentinelOne version
function Get-SentinelOneVersion {
    param (
        [string]$AssetName
    )

    $sentinelFolder = Get-ChildItem "C:\Program Files\SentinelOne" -Directory -ErrorAction SilentlyContinue | Select-Object -First 1 -ExpandProperty FullName

    if ($sentinelFolder) {
        $sentinelVersion = (Get-Item "$sentinelFolder\SentinelAgent.exe").VersionInfo.ProductVersion
        return $sentinelVersion.Trim()
    } else {
        return "SentinelOne folder not found"
    }
}

# Function to check for security patches
function Check-SecurityPatches {
    param (
        [string]$AssetName
    )

    $output = Get-WmiObject -Class 'win32_quickfixengineering' -ErrorAction SilentlyContinue

    if (-not $output) {
        return "No Security Patches Found"
    }

    $securityUpdates = @()

    foreach ($patch in $output) {
        if ($patch.Description -match "Security Update") {
            $installedOnDate = [datetime]::ParseExact($patch.InstalledOn, "yyyyMMdd", $null)
            $securityUpdates += [pscustomobject]@{
                InstalledOn = $installedOnDate
                HotfixID = $patch.HotFixID
            }
        }
    }

    if ($securityUpdates.Count -gt 0) {
        $latestUpdate = $securityUpdates | Sort-Object InstalledOn -Descending | Select-Object -First 1
        return "Latest Security Patch Installed On: $($latestUpdate.InstalledOn.ToString('dd-MM-yyyy')) (HotFixID: $($latestUpdate.HotfixID))"
    } else {
        return "No Security Updates Found"
    }
}

# Function to check NTP configuration (only source and state)
function Check-NTP {
    param (
        [string]$AssetName
    )

    # Run the w32tm command to get NTP peers
    $ntpPeersOutput = w32tm /query /peers 2>&1

    # Check if there's an error in retrieving the NTP peers
    if ($ntpPeersOutput -match "Error") {
        return "NTP Not Configured or Error: $ntpPeersOutput"
    }

    # Initialize variables for source and state
    $ntpSource = "NTP Source: Not Found"
    $ntpState = "NTP State: Not Found"

    # Check if the output contains 'Peers' section
    if ($ntpPeersOutput -match "Peers:\s*(\d+)") {
        $numPeers = [int]$matches[1]
        if ($numPeers -gt 0) {
            # Extract the peer and state information
            $lines = $ntpPeersOutput -split "`n"
            foreach ($line in $lines) {
                if ($line -match "Peer:\s*(.+),\s*0x\d+") {
                    $ntpSource = "NTP Source: $($matches[1].Trim())"
                }
                if ($line -match "State:\s*(.+)") {
                    $ntpState = "NTP State: $($matches[1].Trim())"
                }
            }
        }
    }

    # Return only source and state information
    return "$ntpSource; $ntpState"
}

# Function to check Windows compliance
function Check-ComplianceWindows {
    param (
        [string]$AssetName
    )

    $compliance = @{ }

    # OS information
    $osInfo = Get-WmiObject -Class 'Win32_OperatingSystem' -ErrorAction SilentlyContinue
    $compliance["OS"] = $osInfo.Caption.Trim()

    # SentinelOne status
    $sentinelStatus = Get-Service -Name "SentinelAgent" -ErrorAction SilentlyContinue
    if ($sentinelStatus -and $sentinelStatus.Status -eq 'Running') {
        $sentinelVersion = Get-SentinelOneVersion -AssetName $AssetName
        $compliance["SentinelOne"] = "Running (Version: $sentinelVersion)"
    } else {
        $compliance["SentinelOne"] = "Not Installed or Not Running"
    }

    # Security patches
    $compliance["Patches"] = Check-SecurityPatches -AssetName $AssetName

    # NTP configuration (only source and state)
    $compliance["NTP"] = Check-NTP -AssetName $AssetName

    # Windows activation status
    $activationStatus = Get-WmiObject -Class 'SoftwareLicensingProduct' -ErrorAction SilentlyContinue
    if ($activationStatus.LicenseStatus -eq 1) {
        $compliance["WindowsActivation"] = "Activated"
    } else {
        $compliance["WindowsActivation"] = "Not Activated"
    }

    # WinCollect status
    $wincollectStatus = Get-Service -Name "WinCollect" -ErrorAction SilentlyContinue
    if ($wincollectStatus) {
        $compliance["WinCollect"] = "Running (Display Name: $($wincollectStatus.DisplayName))"
    } else {
        $compliance["WinCollect"] = "Not Installed or Not Running"
    }

    return $compliance
}

# Function to read hostnames from a text file
function Read-Hostnames {
    param (
        [string]$FilePath
    )
    return Get-Content -Path $FilePath
}

# Main function
function Main {
    $hostnameFilePath = "D:\VS CODE\python\comp\test.txt" 
    $csvFilePath = "D:\VS CODE\python\comp\compliance_report.csv" 
    $hostnames = Read-Hostnames -FilePath $hostnameFilePath

    # Create CSV file and write header
    $header = "Hostname,OS,SentinelOne,Patches,NTP,WindowsActivation,WinCollect"
    Set-Content -Path $csvFilePath -Value $header

    foreach ($assetName in $hostnames) {
        Write-Host "Checking $assetName..."
        $complianceResults = Check-ComplianceWindows -AssetName $assetName

        # Prepare row data
        $rowData = "$assetName," + ($complianceResults["OS"]) + "," + ($complianceResults["SentinelOne"]) + "," +
                   ($complianceResults["Patches"]) + "," + ($complianceResults["NTP"]) + "," +
                   ($complianceResults["WindowsActivation"]) + "," + ($complianceResults["WinCollect"])

        # Append row data to CSV
        Add-Content -Path $csvFilePath -Value $rowData
    }

    Write-Host "Compliance report generated successfully at $csvFilePath."
}

# Run the script
Main  
