
// dataIngestion.js

const axios = require('axios');
const { Pool } = require('pg');
const moment = require('moment-timezone');

// --- Direct Configuration Values ---
// Replace these with your actual configuration:
const DB_USER = 'postgres';
const DB_HOST = '10.7.32.134';
const DB_NAME = 'postgres';
const DB_PASSWORD = 'automation@123';
const DB_PORT = 5432;

const API_URL = "https://api-c48.nice-incontact.com/incontactapi/services/v31.0/contacts/completed";
const ACCESS_TOKEN_URL = "http://ctiintegrationapi.operations.fareportal.com.local/api/Agent/accessToken";

// --- Create PostgreSQL Connection Pool ---
const pool = new Pool({
  user: DB_USER,
  host: DB_HOST,
  database: DB_NAME,
  password: DB_PASSWORD,
  port: DB_PORT,
});

// --- Function: initializeDatabase ---
// Creates the "contact_data" table if it does not already exist.
async function initializeDatabase() {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS contact_data (
        id SERIAL PRIMARY KEY,
        abandoned BOOLEAN,
        abandonSeconds BIGINT,
        acwSeconds BIGINT,
        agentId VARCHAR(50),
        agentSeconds BIGINT,
        analyticsProcessedDate TIMESTAMPTZ,
        callbackTime TIMESTAMPTZ,
        conferenceSeconds BIGINT,
        contactId VARCHAR(50),
        campaignId VARCHAR(50),
        campaignName VARCHAR(255),
        contactStartDate TIMESTAMPTZ,
        dateACWWarehoused TIMESTAMPTZ,
        dateContactWarehoused TIMESTAMPTZ,
        dispositionNotes TEXT,
        endReason VARCHAR(255),
        firstName VARCHAR(100),
        lastName VARCHAR(100),
        fromAddress VARCHAR(255),
        highProficiency BOOLEAN,
        holdCount BIGINT,
        holdSeconds BIGINT,
        inQueueSeconds BIGINT,
        isAnalyticsProcessed BOOLEAN,
        isLogged BOOLEAN,
        isOutbound BOOLEAN,
        isRefused BOOLEAN,
        isShortAbandon BOOLEAN,
        isTakeover BOOLEAN,
        lastUpdateTime TIMESTAMPTZ,
        lowProficiency BOOLEAN,
        masterContactId VARCHAR(50),
        mediaSubTypeId VARCHAR(50),
        mediaSubTypeName VARCHAR(255),
        mediaTypeId VARCHAR(50),
        mediaTypeName VARCHAR(255),
        pointOfContactId VARCHAR(50),
        pointOfContactName VARCHAR(255),
        postQueueSeconds BIGINT,
        preQueueSeconds BIGINT,
        primaryDispositionId VARCHAR(50),
        refuseTime TIMESTAMPTZ,
        releaseSeconds BIGINT,
        routingAttribute VARCHAR(255),
        routingTimeSecondary VARCHAR(255),
        DispositionId VARCHAR(50),
        serviceLevelFlag BOOLEAN,
        skillId VARCHAR(50),
        skillName VARCHAR(255),
        teamId VARCHAR(50),
        transferIndicatorId VARCHAR(50),
        transferIndicatorName VARCHAR(255),
        refuseReason TEXT,
        teamName VARCHAR(255),
        toAddress VARCHAR(255),
        totalDurationSeconds BIGINT,
        createdAt TIMESTAMPTZ DEFAULT NOW()
      );
    `;
    await pool.query(createTableQuery);
    console.log("Database initialized – 'contact_data' table is ready.");
  } catch (error) {
    console.error("Error initializing database:", error);
    throw error;
  }
}

// --- Function: getAccessToken ---
// Retrieves an access token from the external API.
async function getAccessToken() {
  try {
    const response = await axios.post(ACCESS_TOKEN_URL);
    console.log("Access token endpoint response:", response.data);
    if (response.data) {
      // Look for both "access token" and "access_token"
      const token = response.data["access token"] || response.data.access_token;
      if (token) {
        console.log("Access token acquired:", token);
        return token;
      }
    }
    throw new Error("Access token missing from response.");
  } catch (error) {
    console.error("Error getting access token:", error);
    throw error;
  }
}

// --- Function: fetchAPIData ---
// Fetches raw data from the external API for the past hour, with pagination.
async function fetchAPIData() {
  try {
    const token = await getAccessToken();
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };

    const endDate = new Date().toISOString();
    const startDate = new Date(Date.now() - 60 * 60 * 1000).toISOString();

    let allRecords = [];
    let skip = 0;
    const top = 10000;

    while (true) {
      const params = {
        startdate: startDate,
        enddate: endDate,
        top: top,
        skip: skip
      };

      const response = await axios.get(API_URL, { headers, params });
      const records = response.data?.completedContacts;
      if (records && records.length > 0) {
        allRecords = allRecords.concat(records);
        skip += top;
        // If less than "top" records were returned, then we have reached the end.
        if (records.length < top) break;
      } else {
        break;
      }
    }
    console.log(`Total records fetched from API: ${allRecords.length}`);
    return allRecords;
  } catch (error) {
    console.error("Error fetching API data:", error);
    return [];
  }
}

// --- Helper: convertToEST ---
// Converts a given date value to Eastern Standard Time (EST).
function convertToEST(dateValue) {
  if (!dateValue) return null;
  return moment.tz(dateValue, 'America/New_York').format();
}

// --- Helper: transformRecord ---
// Transforms the API record keys into the expected keys for insertion,
// applies EST conversion on date fields, and ignores unwanted tags.
function transformRecord(record) {
  return {
    abandoned: record.abandoned,
    abandonSeconds: record.abandonSeconds,
    acwSeconds: record.acwSeconds,
    agentId: record.agentId,
    agentSeconds: record.agentSeconds,
    // The API might return the key as "analytics ProcessedDate" (with a space)
    analyticsProcessedDate: record["analytics ProcessedDate"]
      ? convertToEST(record["analytics ProcessedDate"])
      : (record.analyticsProcessedDate ? convertToEST(record.analyticsProcessedDate) : null),
    callbackTime: record.callbackTime ? convertToEST(record.callbackTime) : null,
    conferenceSeconds: record.conferenceSeconds,
    contactId: record.contactId,
    campaignId: record.campaignId,
    campaignName: record.campaignName,
    contactStartDate: record.contactStartDate ? convertToEST(record.contactStartDate) : null,
    dateACWWarehoused: record.dateACWWarehoused ? convertToEST(record.dateACWWarehoused) : null,
    dateContactWarehoused: record.dateContactWarehoused ? convertToEST(record.dateContactWarehoused) : null,
    dispositionNotes: record.dispositionNotes,
    endReason: record.endReason,
    firstName: record.firstName,
    lastName: record.lastName,
    fromAddress: record.fromAddress,
    highProficiency: record.highProficiency,
    holdCount: record.holdCount,
    holdSeconds: record.holdSeconds,
    inQueueSeconds: record.inQueueSeconds,
    isAnalyticsProcessed: record.isAnalyticsProcessed,
    isLogged: record.islogged || record.isLogged,
    // Some API responses use "1sOutbound" instead of "isOutbound"
    isOutbound: (record["1sOutbound"] !== undefined ? record["1sOutbound"] : record.isOutbound),
    isRefused: record.isRefused,
    isShortAbandon: (record["IsShortAbandon"] !== undefined ? record["IsShortAbandon"] : record.isShortAbandon),
    isTakeover: record.isTakeover,
    lastUpdateTime: record.lastUpdateTime ? convertToEST(record.lastUpdateTime) : null,
    lowProficiency: record.lowProficiency,
    masterContactId: record.masterContactId,
    mediaSubTypeId: record.mediaSubTypeId,
    mediaSubTypeName: record.mediaSubTypeName,
    mediaTypeId: record.mediaTypeId,
    mediaTypeName: record.mediaTypeName,
    pointOfContactId: record.pointOfContactId,
    pointOfContactName: record.pointOfContactName,
    postQueueSeconds: record.postQueueSeconds,
    preQueueSeconds: record.preQueueSeconds,
    primaryDispositionId: record.primaryDispositionId,
    refuseTime: record.refuseTime ? convertToEST(record.refuseTime) : null,
    releaseSeconds: record.releaseSeconds,
    routingAttribute: record.routingAttribute,
    // Some API responses use "routingTime" instead of "routingTimeSecondary"
    routingTimeSecondary: record.routingTime || record.routingTimeSecondary,
    // Some API responses use "secondaryDispositionId" instead of "DispositionId"
    DispositionId: record.secondaryDispositionId || record.DispositionId,
    serviceLevelFlag: record.serviceLevelFlag,
    skillId: record.skillId,
    skillName: record.skillName,
    teamId: record.teamid || record.teamId,
    transferIndicatorId: record["transfer IndicatorId"] || record.transferIndicatorId,
    transferIndicatorName: record["transfer IndicatorName"] || record.transferIndicatorName,
    // We do not want to store tags – set as null.
    refuseReason: record.refuseReason,
    teamName: record.teamName,
    toAddress: record.toAddress,
    totalDurationSeconds: record.totalDurationSeconds
  };
}

// --- Function: insertData ---
// Inserts the transformed records into the PostgreSQL database.
// It skips records that seem to be tag-only (i.e. missing a campaignId).
async function insertData(records) {
  if (!records || records.length === 0) {
    console.log("No records to insert.");
    return;
  }
  let insertedCount = 0;
  for (const record of records) {
    // Skip any record that does not have a campaignId (assuming it is a tag record)
    if (record.campaignId === undefined || record.campaignId === null) {
      console.log("Skipping tag-only record for contactId:", record.contactId);
      continue;
    }

    // Transform the record keys to match the DB columns.
    const transformed = transformRecord(record);

    // Build the insert query.
    // Note: We have removed the "tags" column from insertion (i.e. we are not inserting unwanted tags).
    // The order of values below must match the order of columns.
    const query = `
      INSERT INTO contact_data (
        abandoned, abandonSeconds, acwSeconds, agentId, agentSeconds,
        analyticsProcessedDate, callbackTime, conferenceSeconds, contactId,
        campaignId, campaignName, contactStartDate, dateACWWarehoused,
        dateContactWarehoused, dispositionNotes, endReason, firstName,
        lastName, fromAddress, highProficiency, holdCount, holdSeconds,
        inQueueSeconds, isAnalyticsProcessed, isLogged, isOutbound, isRefused,
        isShortAbandon, isTakeover, lastUpdateTime, lowProficiency,
        masterContactId, mediaSubTypeId, mediaSubTypeName, mediaTypeId,
        mediaTypeName, pointOfContactId, pointOfContactName, postQueueSeconds,
        preQueueSeconds, primaryDispositionId, refuseTime, releaseSeconds,
        routingAttribute, routingTimeSecondary, DispositionId, serviceLevelFlag,
        skillId, skillName, teamId, transferIndicatorId, transferIndicatorName,
        refuseReason, teamName, toAddress, totalDurationSeconds
      )
      VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
        $11, $12, $13, $14, $15, $16, $17, $18, $19, $20,
        $21, $22, $23, $24, $25, $26, $27, $28, $29, $30,
        $31, $32, $33, $34, $35, $36, $37, $38, $39, $40,
        $41, $42, $43, $44, $45, $46, $47, $48, $49, $50,
        $51, $52, $53, $54, $55, $56
      )
    `;

    // Create the values array (order must match the query)
    const values = [
      transformed.abandoned,
      transformed.abandonSeconds,
      transformed.acwSeconds,
      transformed.agentId,
      transformed.agentSeconds,
      transformed.analyticsProcessedDate,
      transformed.callbackTime,
      transformed.conferenceSeconds,
      transformed.contactId,
      transformed.campaignId,
      transformed.campaignName,
      transformed.contactStartDate,
      transformed.dateACWWarehoused,
      transformed.dateContactWarehoused,
      transformed.dispositionNotes,
      transformed.endReason,
      transformed.firstName,
      transformed.lastName,
      transformed.fromAddress,
      transformed.highProficiency,
      transformed.holdCount,
      transformed.holdSeconds,
      transformed.inQueueSeconds,
      transformed.isAnalyticsProcessed,
      transformed.isLogged,
      transformed.isOutbound,
      transformed.isRefused,
      transformed.isShortAbandon,
      transformed.isTakeover,
      transformed.lastUpdateTime,
      transformed.lowProficiency,
      transformed.masterContactId,
      transformed.mediaSubTypeId,
      transformed.mediaSubTypeName,
      transformed.mediaTypeId,
      transformed.mediaTypeName,
      transformed.pointOfContactId,
      transformed.pointOfContactName,
      transformed.postQueueSeconds,
      transformed.preQueueSeconds,
      transformed.primaryDispositionId,
      transformed.refuseTime,
      transformed.releaseSeconds,
      transformed.routingAttribute,
      transformed.routingTimeSecondary,
      transformed.DispositionId,
      transformed.serviceLevelFlag,
      transformed.skillId,
      transformed.skillName,
      transformed.teamId,
      transformed.transferIndicatorId,
      transformed.transferIndicatorName,
      transformed.refuseReason,
      transformed.teamName,
      transformed.toAddress,
      transformed.totalDurationSeconds
    ];

    try {
      await pool.query(query, values);
      insertedCount++;
      console.log(`Inserted record for contactId: ${transformed.contactId}`);
    } catch (error) {
      console.error("Error inserting record for contactId:", transformed.contactId, error);
    }
  }
  console.log(`Inserted ${insertedCount} records into the database.`);
}

// --- Function: fetchAndDump ---
// Fetches data from the API and inserts it into the database.
async function fetchAndDump() {
  console.log("Starting data ingestion process...");
  const records = await fetchAPIData();
  await insertData(records);
}

// --- Function: initialize ---
// Ensures the table exists before running ingestion.
async function initialize() {
  await initializeDatabase();
}

// --- Main Execution ---
(async () => {
  try {
    console.log("Starting initialization...");
    await initialize();
    console.log("Initialization complete. Fetching and inserting data...");
    await fetchAndDump();
    console.log("Data ingestion process complete.");
  } catch (error) {
    console.error("Error in main execution:", error);
  } finally {
    await pool.end();
    console.log("Database pool has been closed.");
  }
})();
