// dataIngestion.js



// --- Create PostgreSQL Connection Pool ---
const pool = new Pool({
  user: DB_USER,
  host: DB_HOST,
  database: DB_NAME,
  password: DB_PASSWORD,
  port: DB_PORT,
});

// --- Function: initializeDatabase ---
// Creates the "contact_data" table if it does not already exist.
// All numeric fields are defined as BIGINT.
async function initializeDatabase() {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS contact_data (
        id SERIAL PRIMARY KEY,
        abandoned BOOLEAN,
        abandonSeconds BIGINT,
        acwSeconds BIGINT,
        agentId VARCHAR(50),
        agentSeconds BIGINT,
        analyticsProcessedDate TIMESTAMPTZ,
        callbackTime TIMESTAMPTZ,
        conferenceSeconds BIGINT,
        contactId VARCHAR(50),
        campaignId VARCHAR(50),
        campaignName VARCHAR(255),
        contactStartDate TIMESTAMPTZ,
        dateACWWarehoused TIMESTAMPTZ,
        dateContactWarehoused TIMESTAMPTZ,
        dispositionNotes TEXT,
        endReason VARCHAR(255),
        firstName VARCHAR(100),
        lastName VARCHAR(100),
        fromAddress VARCHAR(255),
        highProficiency BOOLEAN,
        holdCount BIGINT,
        holdSeconds BIGINT,
        inQueueSeconds BIGINT,
        isAnalyticsProcessed BOOLEAN,
        isLogged BOOLEAN,
        isOutbound BOOLEAN,
        isRefused BOOLEAN,
        isShortAbandon BOOLEAN,
        isTakeover BOOLEAN,
        lastUpdateTime TIMESTAMPTZ,
        lowProficiency BOOLEAN,
        masterContactId VARCHAR(50),
        mediaSubTypeId VARCHAR(50),
        mediaSubTypeName VARCHAR(255),
        mediaTypeId VARCHAR(50),
        mediaTypeName VARCHAR(255),
        pointOfContactId VARCHAR(50),
        pointOfContactName VARCHAR(255),
        postQueueSeconds BIGINT,
        preQueueSeconds BIGINT,
        primaryDispositionId VARCHAR(50),
        refuseTime TIMESTAMPTZ,
        releaseSeconds BIGINT,
        routingAttribute VARCHAR(255),
        routingTimeSecondary VARCHAR(255),
        DispositionId VARCHAR(50),
        serviceLevelFlag BOOLEAN,
        skillId VARCHAR(50),
        skillName VARCHAR(255),
        teamId VARCHAR(50),
        transferIndicatorId VARCHAR(50),
        transferIndicatorName VARCHAR(255),
        tags TEXT,
        refuseReason TEXT,
        teamName VARCHAR(255),
        toAddress VARCHAR(255),
        totalDurationSeconds BIGINT,
        createdAt TIMESTAMPTZ DEFAULT NOW()
      );
    `;
    await pool.query(createTableQuery);
    console.log("Database initialized â€“ 'contact_data' table is ready.");
  } catch (error) {
    console.error("Error initializing database:", error);
    throw error;
  }
}

// --- Function: getAccessToken ---
// Retrieves an access token from the external API.
// Logs the full response for debugging.
async function getAccessToken() {
  try {
    const response = await axios.post(ACCESS_TOKEN_URL);
    console.log("Access token endpoint response:", response.data);
    if (response.data) {
      // Check for both "access token" and "access_token"
      const token = response.data["access token"] || response.data.access_token;
      if (token) {
        console.log("Access token acquired:", token);
        return token;
      }
    }
    throw new Error("Access token missing from response.");
  } catch (error) {
    console.error("Error getting access token:", error);
    throw error;
  }
}

// --- Function: fetchAPIData ---
// Fetches raw data from the external API for the past hour, with pagination.
async function fetchAPIData() {
  try {
    const token = await getAccessToken();
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };

    const endDate = new Date().toISOString();
    const startDate = new Date(Date.now() - 60 * 60 * 1000).toISOString();

    let allRecords = [];
    let skip = 0;
    const top = 10000;

    while (true) {
      const params = {
        startdate: startDate,
        enddate: endDate,
        top: top,
        skip: skip
      };

      const response = await axios.get(API_URL, { headers, params });
      const records = response.data?.completedContacts;
      if (records && records.length > 0) {
        allRecords = allRecords.concat(records);
        skip += top;
        if (records.length < top) {
          break;
        }
      } else {
        break;
      }
    }
    console.log(`Total records fetched: ${allRecords.length}`);
    return allRecords;
  } catch (error) {
    console.error("Error fetching API data:", error);
    return [];
  }
}

// --- Helper: convertToEST ---
// Converts a given date value to Eastern Standard Time (EST).
function convertToEST(dateValue) {
  if (!dateValue) return null;
  return moment.tz(dateValue, 'America/New_York').format();
}

// --- Function: insertData ---
// Inserts the raw records into the PostgreSQL database after converting date fields to EST.
async function insertData(records) {
  if (!records || records.length === 0) {
    console.log("No records to insert.");
    return;
  }
  let insertedCount = 0;
  for (const record of records) {
    // List of date/time fields to convert to EST
    const dateFields = [
      'analyticsProcessedDate',
      'callbackTime',
      'contactStartDate',
      'dateACWWarehoused',
      'dateContactWarehoused',
      'lastUpdateTime',
      'refuseTime'
    ];
    dateFields.forEach(field => {
      if (record[field]) {
        record[field] = convertToEST(record[field]);
      }
    });
    const query = `
      INSERT INTO contact_data (
        abandoned, abandonSeconds, acwSeconds, agentId, agentSeconds,
        analyticsProcessedDate, callbackTime, conferenceSeconds, contactId,
        campaignId, campaignName, contactStartDate, dateACWWarehoused,
        dateContactWarehoused, dispositionNotes, endReason, firstName,
        lastName, fromAddress, highProficiency, holdCount, holdSeconds,
        inQueueSeconds, isAnalyticsProcessed, isLogged, isOutbound, isRefused,
        isShortAbandon, isTakeover, lastUpdateTime, lowProficiency,
        masterContactId, mediaSubTypeId, mediaSubTypeName, mediaTypeId,
        mediaTypeName, pointOfContactId, pointOfContactName, postQueueSeconds,
        preQueueSeconds, primaryDispositionId, refuseTime, releaseSeconds,
        routingAttribute, routingTimeSecondary, DispositionId, serviceLevelFlag,
        skillId, skillName, teamId, transferIndicatorId, transferIndicatorName,
        tags, refuseReason, teamName, toAddress, totalDurationSeconds
      )
      VALUES (
        $1, $2, $3, $4, $5, 
        $6, $7, $8, $9, $10, 
        $11, $12, $13, $14, $15, 
        $16, $17, $18, $19, $20, 
        $21, $22, $23, $24, $25, 
        $26, $27, $28, $29, $30, 
        $31, $32, $33, $34, $35, 
        $36, $37, $38, $39, $40, 
        $41, $42, $43, $44, $45, 
        $46, $47, $48, $49, $50, 
        $51, $52, $53, $54, $55, 
        $56, $57
      )
    `;
    const values = [
      record.abandoned,               // 1
      record.abandonSeconds,          // 2
      record.acwSeconds,              // 3
      record.agentId,                 // 4
      record.agentSeconds,            // 5
      record.analyticsProcessedDate,  // 6
      record.callbackTime,            // 7
      record.conferenceSeconds,       // 8
      record.contactId,               // 9
      record.campaignId,              // 10
      record.campaignName,            // 11
      record.contactStartDate,        // 12
      record.dateACWWarehoused,       // 13
      record.dateContactWarehoused,   // 14
      record.dispositionNotes,        // 15
      record.endReason,               // 16
      record.firstName,               // 17
      record.lastName,                // 18
      record.fromAddress,             // 19
      record.highProficiency,         // 20
      record.holdCount,               // 21
      record.holdSeconds,             // 22
      record.inQueueSeconds,          // 23
      record.isAnalyticsProcessed,    // 24
      record.isLogged,                // 25
      record.isOutbound,              // 26
      record.isRefused,               // 27
      record.isShortAbandon,          // 28
      record.isTakeover,              // 29
      record.lastUpdateTime,          // 30
      record.lowProficiency,          // 31
      record.masterContactId,         // 32
      record.mediaSubTypeId,          // 33
      record.mediaSubTypeName,        // 34
      record.mediaTypeId,             // 35
      record.mediaTypeName,           // 36
      record.pointOfContactId,        // 37
      record.pointOfContactName,      // 38
      record.postQueueSeconds,        // 39
      record.preQueueSeconds,         // 40
      record.primaryDispositionId,    // 41
      record.refuseTime,              // 42
      record.releaseSeconds,          // 43
      record.routingAttribute,        // 44
      record.routingTimeSecondary,    // 45
      record.DispositionId,           // 46
      record.serviceLevelFlag,        // 47
      record.skillId,                 // 48
      record.skillName,               // 49
      record.teamId,                  // 50
      record.transferIndicatorId,     // 51
      record.transferIndicatorName,   // 52
      record.tags,                    // 53
      record.refuseReason,            // 54
      record.teamName,                // 55
      record.toAddress,               // 56
      record.totalDurationSeconds     // 57
    ];

    try {
      await pool.query(query, values);
      insertedCount++;
    } catch (error) {
      console.error("Error inserting record:", error);
    }
  }
  console.log(`Inserted ${insertedCount} records into the database.`);
}

// --- Function: fetchAndDump ---
// Fetches data from the API and inserts it into the database.
async function fetchAndDump() {
  console.log("Starting data ingestion process...");
  const records = await fetchAPIData();
  await insertData(records);
}

// --- Function: initialize ---
// Ensures the table exists before running ingestion.
async function initialize() {
  await initializeDatabase();
}

// --- Main Execution ---
// Wrap the main execution in a try/catch block for error logging.
(async () => {
  try {
    console.log("Starting initialization...");
    await initialize();
    console.log("Initialization complete. Fetching and inserting data...");
    await fetchAndDump();
    console.log("Data ingestion process complete.");
  } catch (error) {
    console.error("Error in main execution:", error);
  } finally {
    pool.end();
  }
})();
