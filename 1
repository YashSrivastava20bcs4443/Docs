st.subheader("Weekly Alerts Analysis")
if not filtered_data.empty:
    weekly_alerts = filtered_data.groupby(['Weekday', 'Day']).size().unstack(fill_value=0)
    weekly_alerts = weekly_alerts.reindex(
        ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'], 
        fill_value=0
    )

    fig, ax = plt.subplots(figsize=(10, 6))
    bars = weekly_alerts.plot(kind='bar', stacked=True, ax=ax, colormap='tab20c', width=0.8)
    ax.set_title("Weekly Alerts Analysis")
    ax.set_xlabel("Weekdays")
    ax.set_ylabel("Number of Alerts")

    # Annotate dates inside the bars
    for container in ax.containers:
        for bar, (day, count) in zip(container, weekly_alerts.stack().index):
            height = bar.get_height()
            if height > 0:
                ax.text(
                    bar.get_x() + bar.get_width() / 2, height / 2, day.strftime('%Y-%m-%d'), 
                    ha='center', va='center', fontsize=8, color='white', rotation=90
                )
    st.pyplot(fig)
else:
    st.write("No data available for Weekly Alerts Analysis.")



st.subheader("Day-wise Alerts Analysis")
if not filtered_data.empty:
    daywise_alerts = filtered_data.groupby(['Day', 'EventLevel']).size().unstack(fill_value=0)
    fig, ax = plt.subplots(figsize=(10, 6))
    daywise_alerts.plot(kind='bar', stacked=True, ax=ax, colormap='tab10')

    # Enhance annotation visibility
    for i, bar_group in enumerate(ax.containers):
        for bar in bar_group:
            height = bar.get_height()
            if height > 0:
                text_color = 'white' if bar.get_facecolor()[0] < 0.5 else 'black'
                ax.text(
                    bar.get_x() + bar.get_width() / 2, height + 1, int(height),
                    ha='center', va='bottom', fontsize=10, color=text_color, fontweight='bold'
                )
    ax.set_title("Day-wise Alerts Analysis")
    ax.set_xlabel("Days")
    ax.set_ylabel("Number of Alerts")
    st.pyplot(fig)
else:
    st.write("No data available for Day-wise Alerts Analysis.")



st.subheader("Alert Correlation Engine")
if not filtered_data.empty:
    correlation_threshold = st.slider("Time Correlation Threshold (minutes):", 1, 30, 5)

    # Step 1: Prepare Data
    filtered_data['TimeDiff'] = filtered_data['@timestamp'].diff().dt.total_seconds().abs() / 60
    filtered_data['Group'] = (filtered_data['TimeDiff'] > correlation_threshold).cumsum()

    # Step 2: Group Alerts
    correlations = (
        filtered_data.groupby(['Group', 'EventSource', 'EventLevel'])[['EventTitle']]
        .size()
        .reset_index(name='Count')
    )
    st.write("Correlated Alerts Summary:", correlations)

    # Step 3: Heatmap for Visualization
    heatmap_data = correlations.pivot_table(
        index='EventSource', columns='EventLevel', values='Count', aggfunc='sum', fill_value=0
    )
    fig, ax = plt.subplots(figsize=(12, 6))
    sns.heatmap(heatmap_data, annot=True, fmt="d", cmap="Blues", linewidths=0.5, ax=ax)
    ax.set_title("Alert Correlation Heatmap")
    st.pyplot(fig)

    # Export Correlated Alerts
    st.download_button(
        label="Download Correlation Report",
        data=correlations.to_csv(index=False).encode('utf-8'),
        file_name='correlation_report.csv',
        mime='text/csv'
    )
else:
    st.write("No data available for Alert Correlation Engine.")
