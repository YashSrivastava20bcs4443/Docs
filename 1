def analyze_cascading_dependencies(filtered_data):
    """
    Analyzes cascading alert dependencies based on predefined rules and updates the Streamlit dashboard.
    
    Args:
        filtered_data (pd.DataFrame): The filtered data from your existing Streamlit app.
    """
    # Define cascading dependencies
    dependency_map = {
        'Server': ['Network', 'Application'],
        'Network': ['Application'],
        'Application': ['Application'],  # Application to Application dependency
    }

    # Ensure data has necessary columns
    required_columns = ['@timestamp', 'EventSource', 'EventTitle', 'EventLevel']
    if not all(col in filtered_data.columns for col in required_columns):
        st.error("Filtered data is missing required columns for cascading analysis.")
        return

    # Convert timestamp to datetime if not already done
    filtered_data['@timestamp'] = pd.to_datetime(filtered_data['@timestamp'], errors='coerce')

    # Sort data by timestamp
    filtered_data = filtered_data.sort_values(by='@timestamp')

    # Analyze dependencies
    cascading_results = []
    for index, row in filtered_data.iterrows():
        current_source = row['EventSource']
        current_time = row['@timestamp']
        dependencies = dependency_map.get(current_source, [])

        for dependency in dependencies:
            related_alerts = filtered_data[
                (filtered_data['EventSource'] == dependency)
                & (filtered_data['@timestamp'] > current_time)
                & (filtered_data['@timestamp'] <= current_time + pd.Timedelta(minutes=30))
            ]

            for _, related_row in related_alerts.iterrows():
                cascading_results.append({
                    'Primary Alert Source': current_source,
                    'Primary Alert Time': current_time,
                    'Dependent Alert Source': related_row['EventSource'],
                    'Dependent Alert Time': related_row['@timestamp'],
                    'Dependent Event Title': related_row['EventTitle'],
                })

    # Create a DataFrame for cascading results
    cascading_df = pd.DataFrame(cascading_results)

    if cascading_df.empty:
        st.write("No cascading dependencies found in the selected data.")
    else:
        st.subheader("Cascading Dependency Analysis")

        # Display results in Streamlit
        st.write("### Cascading Dependency Results")
        st.write(cascading_df)

        # Download option for cascading results
        csv_data = cascading_df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label="Download Cascading Results as CSV",
            data=csv_data,
            file_name='cascading_results.csv',
            mime='text/csv',
        )

# Integrate the function into your existing Streamlit app
if not filtered_data.empty:
    analyze_cascading_dependencies(filtered_data)
