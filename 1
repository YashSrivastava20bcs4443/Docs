const axios = require("axios");
const { Pool } = require("pg");
const moment = require("moment-timezone");
const fs = require("fs-extra");
const fastCsv = require("fast-csv");
require("dotenv").config();

// API Endpoints
const API_URL =
  "https://api-c48.nice-incontact.com/incontactapi/services/v31.0/contacts/completed";
const ACCESS_TOKEN_URL =
  "http://ctiintegrationapi.operations.fareportal.com.local/api/Agent/accessToken";

// PostgreSQL Configuration
const pool = new Pool({
  user: "postgres",
  host: "10.7.32.134",
  database: "postgres",
  password: "automation@123",
  port: 5432,
});

// Directory Setup
const scriptDir = __dirname;
const tempDir = `${scriptDir}/Temp`;

if (!fs.existsSync(tempDir)) {
  fs.mkdirSync(tempDir, { recursive: true });
  console.log(`Directory created or exists: ${tempDir}`);
}

// Function to get access token
async function getAccessToken() {
  try {
    const response = await axios.post(ACCESS_TOKEN_URL);
    if (response.data.access_token) {
      console.log("Access Token generated successfully.");
      return response.data.access_token;
    }
    throw new Error("Failed to generate access token");
  } catch (error) {
    console.error("Error getting access token:", error);
    process.exit(1);
  }
}

// Function to fetch data from API
async function fetchData(startDate, endDate, authToken) {
  let allData = [];
  let top = 10000;
  let skip = 0;

  try {
    while (true) {
      const response = await axios.get(API_URL, {
        headers: {
          Authorization: `Bearer ${authToken}`,
          "Content-Type": "application/json",
        },
        params: { startdate: startDate, enddate: endDate, top, skip },
      });

      const data = response.data.completedContacts || [];
      allData.push(...data);
      skip += top;

      if (data.length < top) break;
    }

    console.log(`Total records fetched: ${allData.length}`);
    return allData;
  } catch (error) {
    console.error("Error fetching data:", error);
    return [];
  }
}

// Function to save data to CSV
async function saveRawDataToCsv(data) {
  return new Promise((resolve, reject) => {
    const filePath = `${tempDir}/Raw_data.csv`;
    const ws = fs.createWriteStream(filePath);

    fastCsv
      .write(data, { headers: true })
      .pipe(ws)
      .on("finish", () => {
        console.log(`Raw data saved to '${filePath}' successfully!`);
        resolve(filePath);
      })
      .on("error", reject);
  });
}

// Function to remove 'tags' column
async function dropTagsColumn(csvFilePath) {
  return new Promise((resolve, reject) => {
    let newData = [];

    fs.createReadStream(csvFilePath)
      .pipe(fastCsv.parse({ headers: true }))
      .on("data", (row) => {
        delete row.tags;
        newData.push(row);
      })
      .on("end", () => {
        fastCsv
          .writeToPath(csvFilePath, newData, { headers: true })
          .on("finish", () => {
            console.log(`'tags' column removed from '${csvFilePath}'`);
            resolve();
          })
          .on("error", reject);
      })
      .on("error", reject);
  });
}

// Function to insert data into PostgreSQL
async function insertDataIntoDB(csvFilePath) {
  const client = await pool.connect();
  try {
    const tableName = "raw_contact_data";
    let columns = [];
    let rows = [];

    const data = await new Promise((resolve, reject) => {
      let records = [];
      fs.createReadStream(csvFilePath)
        .pipe(fastCsv.parse({ headers: true }))
        .on("data", (row) => records.push(row))
        .on("end", () => resolve(records))
        .on("error", reject);
    });

    if (data.length === 0) {
      console.log("No data found in CSV.");
      return;
    }

    columns = Object.keys(data[0]);

    // Convert datetime columns to EST
    for (let row of data) {
      let formattedRow = {};
      for (let col of columns) {
        if (row[col] && moment(row[col], moment.ISO_8601, true).isValid()) {
          formattedRow[col] = moment(row[col]).tz("America/New_York").format();
        } else {
          formattedRow[col] = row[col];
        }
      }
      rows.push(formattedRow);
    }

    // Create Table
    const columnDefinitions = columns
      .map((col) => `"${col}" TIMESTAMPTZ`)
      .join(", ");
    await client.query(`CREATE TABLE IF NOT EXISTS ${tableName} (${columnDefinitions})`);

    // Insert Data
    for (let row of rows) {
      const values = columns.map((col) => row[col]);
      const placeholders = columns.map((_, i) => `$${i + 1}`).join(", ");
      await client.query(
        `INSERT INTO ${tableName} (${columns.map((col) => `"${col}"`).join(", ")}) VALUES (${placeholders})`,
        values
      );
    }

    console.log(`Data inserted into table '${tableName}' successfully!`);
  } catch (error) {
    console.error("Error inserting data into database:", error);
  } finally {
    client.release();
  }
}

// Function to delete CSV file
function deleteCsv(csvFilePath) {
  fs.unlink(csvFilePath, (err) => {
    if (err) console.error("Error deleting CSV file:", err);
    else console.log(`CSV file '${csvFilePath}' deleted successfully!`);
  });
}

// Main Execution
(async function main() {
  try {
    const authToken = await getAccessToken();
    const endDate = moment().tz("America/New_York").format("YYYY-MM-DDTHH:mm:ss[Z]");
    const startDate = moment().tz("America/New_York").subtract(1, "hour").format("YYYY-MM-DDTHH:mm:ss[Z]");

    const data = await fetchData(startDate, endDate, authToken);

    if (data.length > 0) {
      const csvFilePath = await saveRawDataToCsv(data);
      await dropTagsColumn(csvFilePath);
      await insertDataIntoDB(csvFilePath);
      deleteCsv(csvFilePath);
    } else {
      console.log("No data fetched for the given time range.");
    }
  } catch (error) {
    console.error("Error in execution:", error);
  }
})();
