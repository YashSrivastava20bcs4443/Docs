const { error, Console } = require('console');
const express = require('express');
const fs = require('fs');
const csvjson = require('csvjson');
const { Pool } = require('pg');
const cors = require('cors');
const app = express();
app.use(cors());
app.use(express.json());
const pool = new Pool({
    host: '10.7.32.134',
    user: 'postgres',
    password: 'automation@123',
    database: 'postgres',
    port: 5432
});

app.get('/api/stats', async (req, res) => {
    try {
        const { startDate, endDate, portal, tfn } = req.query;
        let query = `
            SELECT
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4') AS ivr_offered,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric = 0 AND "abandoned" = 'True' AND "preQueueSeconds"::numeric > 0) AS ivr_abandoned,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric > 0 AND "abandoned" = 'True') AS queue_abandoned,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric = 0 AND "abandoned" = 'False' AND "preQueueSeconds"::numeric > 0) AS closed_by_ivr,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "abandoned" = 'True' AND "preQueueSeconds"::numeric < 10) AS abandoned_in_10_sec,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "abandoned" = 'True' AND "preQueueSeconds"::numeric > 10) AS abandoned_in_over_10_sec,
            COUNT(*) FILTER (WHERE "masterContactId" = "contactId" AND "isOutbound" = 'False' AND "mediaTypeId" = '4' AND "abandoned" = 'False' AND "agentSeconds"::numeric > 0) AS answered_calls
            FROM contact_mapped_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        if (portal) {
            query += queryParams.length ? ' AND' : ' WHERE';
            query += ' "Portal" = $3';
            queryParams.push(portal);
        }

        if (tfn) {
            query += queryParams.length ? ' AND' : ' WHERE';
            query += ' "TFN Type" = $4';
            queryParams.push(tfn);
        }

        const result = await pool.query(query, queryParams);
        res.json(result.rows[0]);
    } catch (err) {
        console.error('Error fetching stats:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/detail', async (req, res) => {
    try {
        const { category, startDate, endDate, portal, tfn } = req.query;
        let query = `
            SELECT "toAddress" AS "TFN", "Description", COUNT(*) AS count
            FROM contact_mapped_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        if (portal) {
            query += queryParams.length ? ' AND' : ' WHERE';
            query += ' "Portal" = $3';
            queryParams.push(portal);
        }

        if (tfn) {
            query += queryParams.length ? ' AND' : ' WHERE';
            query += ' "TFN Type" = $4';
            queryParams.push(tfn);
        }

        switch(category) {
            case 'ivr_offered':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\'';
                break;
            case 'ivr_abandoned':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric = 0 AND "abandoned" = \'True\' AND "preQueueSeconds"::numeric > 0';
                break;
            case 'queue_abandoned':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric > 0 AND "abandoned" = \'True\'';
                break;
            case 'closed_by_ivr':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "agentSeconds"::numeric = 0 AND "inQueueSeconds"::numeric = 0 AND "abandoned" = \'False\' AND "preQueueSeconds"::numeric > 0';
                break;
            case 'abandoned_under_10':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "abandoned" = \'True\' AND "preQueueSeconds"::numeric < 10';
                break;
            case 'abandoned_over_10':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "abandoned" = \'True\' AND "preQueueSeconds"::numeric > 10';
                break;
            case 'answered_calls':
                query += ' AND "masterContactId" = "contactId" AND "isOutbound" = \'False\' AND "mediaTypeId" = \'4\' AND "abandoned" = \'False\' AND "agentSeconds"::numeric > 0';
                break;
            default:
                return res.status(400).json({ error: 'Invalid category' });
        }

        query += ' GROUP BY "toAddress", "Description"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching detail data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/tfn-wise', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT 
                "toAddress" AS "Number (toAddress)",  
                COUNT(*) AS offered_calls,
                SUM(CASE 
                        WHEN CAST(NULLIF("abandoned", '') AS BOOLEAN) = FALSE 
                             AND NULLIF("agentSeconds", '') ~ '^[0-9]+(\\.[0-9]+)?$'  
                        THEN NULLIF("agentSeconds", '')::FLOAT::INTEGER ELSE 0 
                    END) AS answered,
                SUM(CASE 
                        WHEN CAST(NULLIF("abandoned", '') AS BOOLEAN) = TRUE 
                             AND (NULLIF("inQueueSeconds", '') IS NULL OR NULLIF("inQueueSeconds", '') = '' OR NULLIF("inQueueSeconds", '')::FLOAT::INTEGER = 0) 
                        THEN 1 ELSE 0 
                    END) AS ivr_abandon,
                SUM(CASE 
                        WHEN CAST(NULLIF("abandoned", '') AS BOOLEAN) = TRUE 
                             AND NULLIF("inQueueSeconds", '') ~ '^[0-9]+(\\.[0-9]+)?$'  
                        THEN NULLIF("inQueueSeconds", '')::FLOAT::INTEGER ELSE 0 
                    END) AS queue_abandon,
                SUM(CASE 
                        WHEN CAST(NULLIF("abandoned", '') AS BOOLEAN) = TRUE 
                             AND "endReason" IN ('Contact Hung Up', 'Contact Hang Up via Script') 
                        THEN 1 ELSE 0 
                    END) AS polite_disconnect
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "toAddress" ORDER BY offered_calls DESC';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching TFN-Wise data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/ivr-bucket', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            WITH processed_data AS (
                SELECT 
                    TO_TIMESTAMP("contactStartDate", 'YYYY-MM-DD HH24:MI:SS') AS contact_start_time,
                    "toAddress",
                    "abandoned",
                    COALESCE(NULLIF("preQueueSeconds", '')::FLOAT::INTEGER, 0) AS ivr_duration
                FROM contact_data
                WHERE "contactStartDate" IS NOT NULL
            )
            SELECT 
                DATE_TRUNC('hour', contact_start_time) AS time_interval,  
                COUNT(*) AS offered_calls,  
                SUM(CASE WHEN abandoned = 'true' THEN 1 ELSE 0 END) AS ivr_abandon,
                SUM(CASE WHEN ivr_duration BETWEEN 0 AND 30 THEN 1 ELSE 0 END) AS "0-30 Seconds",
                SUM(CASE WHEN ivr_duration BETWEEN 31 AND 60 THEN 1 ELSE 0 END) AS "30-60 Seconds",
                SUM(CASE WHEN ivr_duration BETWEEN 61 AND 120 THEN 1 ELSE 0 END) AS "60-120 Seconds",
                SUM(CASE WHEN ivr_duration > 120 THEN 1 ELSE 0 END) AS ">120 Seconds"
            FROM processed_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date(contact_start_time::TEXT, \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY time_interval ORDER BY time_interval';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching IVR Bucket data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/in-queue-campaign', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "campaignName" AS "Campaign", COUNT(*) AS call_count
            FROM contact_data
            WHERE "inQueueSeconds"::numeric > 0
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' AND to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "campaignName"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching in-queue campaign data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/queue-metrics', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT 
                AVG("preQueueSeconds"::numeric) AS avg_pre_queue,
                AVG("inQueueSeconds"::numeric) AS avg_in_queue,
                AVG("postQueueSeconds"::numeric) AS avg_post_queue
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        const result = await pool.query(query, queryParams);
        res.json(result.rows[0]);
    } catch (err) {
        console.error('Error fetching queue metrics data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/top-agents', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "agentId" AS "Agent", COUNT(*) AS call_count
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "agentId" ORDER BY call_count DESC LIMIT 5';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching top agents data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/call-disposition', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "endReason" AS "EndReason", COUNT(*) AS call_count
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "endReason"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching call disposition data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/calls-over-time', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT DATE_TRUNC('minute', TO_TIMESTAMP("contactStartDate", 'YYYY-MM-DD HH24:MI:SS')) AS time_interval, COUNT(*) AS call_count
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY time_interval ORDER BY time_interval';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching calls over time data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/calls-by-campaign', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "campaignName" AS "Campaign", COUNT(*) AS call_count
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "campaignName"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching calls by campaign data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/average-handle-time', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "skillName" AS "Skill", AVG("agentSeconds"::numeric) AS avg_handle_time
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "skillName"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching average handle time data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

app.get('/api/call-transfers', async (req, res) => {
    try {
        const { startDate, endDate } = req.query;
        let query = `
            SELECT "transferIndicatorName" AS "TransferIndicator", COUNT(*) AS call_count
            FROM contact_data
        `;

        const queryParams = [];

        if (startDate && endDate) {
            query += ' WHERE to_date("contactStartDate", \'YYYY-MM-DD\') BETWEEN $1 AND $2';
            queryParams.push(startDate, endDate);
        }

        query += ' GROUP BY "transferIndicatorName"';
        const result = await pool.query(query, queryParams);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching call transfers data:', err);
        res.status(500).json({ error: 'Internal Server Error' });
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
