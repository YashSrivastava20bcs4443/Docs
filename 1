const axios = require('axios');
const { Pool } = require('pg');
const moment = require('moment-timezone');
const fs = require('fs');
const { Parser } = require('json2csv');

// --- Configuration ---
const DB_USER = 'postgres';
const DB_HOST = '10.7.32.134';
const DB_NAME = 'postgres';
const DB_PASSWORD = 'automation@123';
const DB_PORT = 5432;

const API_URL = "https://api-c48.nice-incontact.com/incontactapi/services/v31.0/contacts/completed";
const ACCESS_TOKEN_URL = "http://ctiintegrationapi.operations.fareportal.com.local/api/Agent/accessToken";
const CSV_FILE = "data.csv";

// --- PostgreSQL Connection ---
const pool = new Pool({
  user: DB_USER,
  host: DB_HOST,
  database: DB_NAME,
  password: DB_PASSWORD,
  port: DB_PORT,
});

// --- Function: initializeDatabase ---
async function initializeDatabase() {
  try {
    const createTableQuery = `
      CREATE TABLE IF NOT EXISTS contact_data (
        id SERIAL PRIMARY KEY,
        abandoned BOOLEAN,
        abandonSeconds BIGINT,
        acwSeconds BIGINT,
        agentId VARCHAR(50),
        agentSeconds BIGINT,
        analyticsProcessedDate TIMESTAMPTZ,
        callbackTime TIMESTAMPTZ,
        conferenceSeconds BIGINT,
        contactId VARCHAR(50),
        campaignId VARCHAR(50),
        campaignName VARCHAR(255),
        contactStartDate TIMESTAMPTZ,
        dateACWWarehoused TIMESTAMPTZ,
        dateContactWarehoused TIMESTAMPTZ,
        dispositionNotes TEXT,
        endReason VARCHAR(255),
        firstName VARCHAR(100),
        lastName VARCHAR(100),
        fromAddress VARCHAR(255),
        highProficiency BOOLEAN,
        holdCount BIGINT,
        holdSeconds BIGINT,
        inQueueSeconds BIGINT,
        isAnalyticsProcessed BOOLEAN,
        isLogged BOOLEAN,
        isOutbound BOOLEAN,
        isRefused BOOLEAN,
        isShortAbandon BOOLEAN,
        isTakeover BOOLEAN,
        lastUpdateTime TIMESTAMPTZ,
        lowProficiency BOOLEAN,
        masterContactId VARCHAR(50),
        mediaSubTypeId VARCHAR(50),
        mediaSubTypeName VARCHAR(255),
        mediaTypeId VARCHAR(50),
        mediaTypeName VARCHAR(255),
        pointOfContactId VARCHAR(50),
        pointOfContactName VARCHAR(255),
        postQueueSeconds BIGINT,
        preQueueSeconds BIGINT,
        primaryDispositionId VARCHAR(50),
        refuseTime TIMESTAMPTZ,
        releaseSeconds BIGINT,
        routingAttribute VARCHAR(255),
        routingTimeSecondary VARCHAR(255),
        DispositionId VARCHAR(50),
        serviceLevelFlag BOOLEAN,
        skillId VARCHAR(50),
        skillName VARCHAR(255),
        teamId VARCHAR(50),
        transferIndicatorId VARCHAR(50),
        transferIndicatorName VARCHAR(255),
        refuseReason TEXT,
        teamName VARCHAR(255),
        toAddress VARCHAR(255),
        totalDurationSeconds BIGINT,
        createdAt TIMESTAMPTZ DEFAULT NOW()
      );
    `;
    await pool.query(createTableQuery);
    console.log("Database initialized â€“ 'contact_data' table is ready.");
  } catch (error) {
    console.error("Error initializing database:", error);
    throw error;
  }
}

// --- Function: getAccessToken ---
async function getAccessToken() {
  try {
    const response = await axios.post(ACCESS_TOKEN_URL);
    if (response.data) {
      const token = response.data["access token"] || response.data.access_token;
      if (token) return token;
    }
    throw new Error("Access token missing from response.");
  } catch (error) {
    console.error("Error getting access token:", error);
    throw error;
  }
}

// --- Function: fetchAPIData ---
async function fetchAPIData() {
  try {
    const token = await getAccessToken();
    const headers = {
      "Authorization": `Bearer ${token}`,
      "Content-Type": "application/json"
    };

    const endDate = new Date().toISOString();
    const startDate = new Date(Date.now() - 60 * 60 * 1000).toISOString();

    let allRecords = [];
    let skip = 0;
    const top = 10000;

    while (true) {
      const params = { startdate: startDate, enddate: endDate, top: top, skip: skip };
      const response = await axios.get(API_URL, { headers, params });
      const records = response.data?.completedContacts;
      if (records && records.length > 0) {
        allRecords = allRecords.concat(records);
        skip += top;
        if (records.length < top) break;
      } else break;
    }
    console.log(`Total records fetched: ${allRecords.length}`);
    return allRecords;
  } catch (error) {
    console.error("Error fetching API data:", error);
    return [];
  }
}

// --- Function: convertToEST ---
function convertToEST(dateValue) {
  return dateValue ? moment.tz(dateValue, 'America/New_York').format() : null;
}

// --- Function: saveToCSV ---
async function saveToCSV(records) {
  try {
    if (records.length === 0) {
      console.log("No data to save to CSV.");
      return false;
    }

    // Remove "tags" column and convert date fields to EST
    const processedRecords = records.map(record => {
      const {
        tags, // Removing tags column
        analyticsProcessedDate,
        callbackTime,
        contactStartDate,
        dateACWWarehoused,
        dateContactWarehoused,
        lastUpdateTime,
        refuseTime,
        ...rest
      } = record;

      return {
        ...rest,
        analyticsProcessedDate: convertToEST(analyticsProcessedDate),
        callbackTime: convertToEST(callbackTime),
        contactStartDate: convertToEST(contactStartDate),
        dateACWWarehoused: convertToEST(dateACWWarehoused),
        dateContactWarehoused: convertToEST(dateContactWarehoused),
        lastUpdateTime: convertToEST(lastUpdateTime),
        refuseTime: convertToEST(refuseTime)
      };
    });

    const json2csv = new Parser();
    const csv = json2csv.parse(processedRecords);
    fs.writeFileSync(CSV_FILE, csv);
    console.log(`Data saved to CSV: ${CSV_FILE}`);
    return true;
  } catch (error) {
    console.error("Error saving data to CSV:", error);
    return false;
  }
}

// --- Function: insertFromCSV ---
async function insertFromCSV() {
  try {
    if (!fs.existsSync(CSV_FILE)) {
      console.log("CSV file not found. Skipping database insertion.");
      return;
    }

    const fileContent = fs.readFileSync(CSV_FILE, 'utf8');
    const rows = fileContent.split('\n').slice(1); // Skip header

    let insertedCount = 0;
    for (const row of rows) {
      if (!row.trim()) continue;
      const values = row.split(','); // Assuming no commas inside values
      const query = `
        INSERT INTO contact_data (
          abandoned, abandonSeconds, acwSeconds, agentId, agentSeconds, 
          analyticsProcessedDate, callbackTime, conferenceSeconds, contactId, 
          campaignId, campaignName, contactStartDate, dateACWWarehoused, 
          dateContactWarehoused, dispositionNotes, endReason, firstName, 
          lastName, fromAddress, highProficiency, holdCount, holdSeconds, 
          inQueueSeconds, isAnalyticsProcessed, isLogged, isOutbound, isRefused, 
          isShortAbandon, isTakeover, lastUpdateTime, lowProficiency, 
          masterContactId, mediaSubTypeId, mediaSubTypeName, mediaTypeId, 
          mediaTypeName, pointOfContactId, pointOfContactName, postQueueSeconds, 
          preQueueSeconds, primaryDispositionId, refuseTime, releaseSeconds, 
          routingAttribute, routingTimeSecondary, DispositionId, serviceLevelFlag, 
          skillId, skillName, teamId, transferIndicatorId, transferIndicatorName, 
          refuseReason, teamName, toAddress, totalDurationSeconds
        ) VALUES (${values.map((_, i) => `$${i + 1}`).join(', ')})
      `;
      await pool.query(query, values);
      insertedCount++;
    }
    console.log(`Inserted ${insertedCount} records into database.`);
    fs.unlinkSync(CSV_FILE);
    console.log("CSV file deleted.");
  } catch (error) {
    console.error("Error inserting data into database:", error);
  }
}

// --- Execution ---
(async () => {
  await initializeDatabase();
  const records = await fetchAPIData();
  if (await saveToCSV(records)) await insertFromCSV();
})();
