import pandas as pd

# Step 1: Load the Original CSV File
# Replace 'your_original_data.csv' with the path to your actual CSV file
original_data = pd.read_csv('your_original_data.csv')

# Step 2: Filter and Clean the Data
# Drop rows where 'Interval' (date) is missing
cleaned_data = original_data.dropna(subset=['Interval'])

# Convert 'Interval' to datetime format using .loc to avoid SettingWithCopyWarning
cleaned_data.loc[:, 'Interval'] = pd.to_datetime(cleaned_data['Interval'], format='%m/%d/%Y')

# Keep only relevant columns
cleaned_data = cleaned_data[['Rule', 'Interval', 'Average', 'Max', 'Min', 'StandardDeviation']]

# Optional: Reset the index if needed
cleaned_data.reset_index(drop=True, inplace=True)

# Step 3: Save the Cleaned Data to a New CSV File
# Replace 'cleaned_data.csv' with the desired name and path for your new CSV file
cleaned_data.to_csv('cleaned_data.csv', index=False)

print("Cleaned data has been saved to 'cleaned_data.csv'.")
import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_absolute_error, mean_squared_error

# Step 1: Load the Cleaned Data
cleaned_data = pd.read_csv('cleaned_data.csv')

# Convert 'Interval' to datetime format
cleaned_data['Interval'] = pd.to_datetime(cleaned_data['Interval'])

# Step 2: Combine CPU and Memory Data
cpu_data = cleaned_data[cleaned_data['Rule'].str.contains('Processor')].set_index('Interval')
memory_data = cleaned_data[cleaned_data['Rule'].str.contains('Memory')].set_index('Interval')

combined_data = pd.DataFrame({
    'CPU_Average': cpu_data['Average'],
    'Memory_Average': memory_data['Average']
}).dropna()

# Step 3: Split Data into Training and Testing Sets
train_size = int(len(combined_data) * 0.8)  # 80% for training, 20% for testing
train_data = combined_data[:train_size]
test_data = combined_data[train_size:]

# Step 4: Train and Test the ARIMA Model for CPU Usage
cpu_model = ARIMA(train_data['CPU_Average'], order=(5, 1, 0))
cpu_model_fit = cpu_model.fit()

# Forecast CPU usage on the test data
cpu_forecast = cpu_model_fit.forecast(steps=len(test_data))

# Calculate accuracy for CPU
cpu_mae = mean_absolute_error(test_data['CPU_Average'], cpu_forecast)
cpu_rmse = mean_squared_error(test_data['CPU_Average'], cpu_forecast, squared=False)

# Step 5: Train and Test the ARIMA Model for Memory Usage
memory_model = ARIMA(train_data['Memory_Average'], order=(5, 1, 0))
memory_model_fit = memory_model.fit()

# Forecast Memory usage on the test data
memory_forecast = memory_model_fit.forecast(steps=len(test_data))

# Calculate accuracy for Memory
memory_mae = mean_absolute_error(test_data['Memory_Average'], memory_forecast)
memory_rmse = mean_squared_error(test_data['Memory_Average'], memory_forecast, squared=False)

# Step 6: Print the Accuracy Metrics
print(f'CPU Usage MAE: {cpu_mae:.2f}')
print(f'CPU Usage RMSE: {cpu_rmse:.2f}')
print(f'Memory Usage MAE: {memory_mae:.2f}')
print(f'Memory Usage RMSE: {memory_rmse:.2f}')

# Step 7: Visualization
plt.figure(figsize=(14, 7))
plt.plot(test_data.index, test_data['CPU_Average'], label='Actual CPU Usage')
plt.plot(test_data.index, cpu_forecast, label='Forecasted CPU Usage', linestyle='--')
plt.plot(test_data.index, test_data['Memory_Average'], label='Actual Memory Usage')
plt.plot(test_data.index, memory_forecast, label='Forecasted Memory Usage', linestyle='--')
plt.title('Actual vs Forecasted CPU and Memory Usage')
plt.xlabel('Date')
plt.ylabel('Usage (%)')
plt.legend()
plt.show()
