import re

def decode_vbe_text(encoded_content):
    try:
        # Remove leading/trailing whitespace
        encoded_content = encoded_content.strip()

        # Debugging: Show first 50 characters
        print(f"First 50 characters of input: {encoded_content[:50]}")

        # Check for #@~^ marker
        if not encoded_content.startswith('#@~^'):
            print("Error: Input does not start with #@~^ marker.")
            print("This may not be a valid .vbe encoded string.")
            return None

        # Try to find encoded data with flexible regex
        match = re.search(r'#@~[\^](.*?)(==\^@#|$)', encoded_content, re.DOTALL)
        if not match:
            print("Error: Could not find encoded data between #@~^ and ==^@#.")
            print("Possible issues: Missing ==^@# marker or non-standard encoding.")
            return None

        encoded_data = match.group(1)
        print(f"Found encoded data (length: {len(encoded_data)} characters)")

        # VBE encoding key table (simplified)
        key_table = [
            [chr(i) for i in range(128)],
            [chr(i) for i in range(128)],
            [chr(i) for i in range(128)]
        ]

        # Decode the script
        decoded = ''
        escape = False
        table_index = 0

        i = 0
        while i < len(encoded_data):
            char = encoded_data[i]

            if char == '@' and not escape:
                escape = True
                i += 1
                continue

            if escape:
                if char == '&':
                    decoded += '\r\n'
                elif char == '#':
                    decoded += '\r'
                elif char == '(':
                    table_index = (table_index + 1) % 3
                elif char == ')':
                    table_index = (table_index - 1) % 3
                elif char == '^':
                    decoded += '@'
                elif char == '+':
                    decoded += ' '
                elif char == '<':
                    decoded += '<'
                elif char == '>':
                    decoded += '>'
                elif char == '*':
                    decoded += '*'
                elif char == '/':
                    decoded += '/'
                else:
                    decoded += char  # Handle unexpected escape chars
                escape = False
            else:
                if ord(char) < 128:
                    decoded += key_table[table_index][ord(char)]
                else:
                    decoded += char

            i += 1

        return decoded

    except Exception as e:
        print(f"Error during decoding: {str(e)}")
        return None

def main():
    print("Paste or type the .vbe encoded text below (press Enter twice to finish):")
    
    # Collect multi-line input until two consecutive newlines
    lines = []
    while True:
        line = input()
        if line == "" and lines and lines[-1] == "":
            break
        lines.append(line)
    
    # Join the input lines
    encoded_content = "\n".join(lines).strip()

    if not encoded_content:
        print("Error: No input provided.")
        return

    # Decode the input
    decoded = decode_vbe_text(encoded_content)

    # Display the result
    if decoded:
        print("\nDecoded VBScript:\n")
        print(decoded)
    else:
        print("\nNo decoded output generated.")

if __name__ == "__main__":
    main()
