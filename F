import os
import shutil
import time
import pandas as pd
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from openpyxl import load_workbook
from openpyxl.styles import PatternFill, Font, Border, Side
from openpyxl.utils.dataframe import dataframe_to_rows
from email.message import EmailMessage
import smtplib
import config

# Configure WebDriver options
download_directory = os.path.join(os.getcwd(), "downloads")
temp_directory = os.path.join(os.getcwd(), "temp")
chrome_options = webdriver.ChromeOptions()
chrome_options.add_experimental_option("prefs", {
    "download.default_directory": temp_directory,
    "download.prompt_for_download": False,
    "safebrowsing.enabled": True
})
driver_path = 'C:\\Users\\y.s.va22\\Downloads\\prod\\chromedriver.exe'

# List of FortiGate firewall IPs with location
firewall_ips = [
    ('172.16.125.10', 'OKR 1'),
    ('172.16.125.11', 'GCR'),
    ('172.16.125.12', 'Pune'),
    ('172.16.125.13', 'Mexico'),
    ('172.16.125.14', 'LI'),
    ('172.16.125.15', 'Canada'),
    ('172.16.125.16', 'New York'),
    ('172.16.125.17', 'NDJC 1'),
    ('172.16.125.18', 'LV'),
    ('172.16.125.19', 'OKR 2'),
    ('172.16.125.20', 'NDJC 2'),
    ('172.16.125.21', 'NDJC 3')
]

# Shared FortiGate credentials
username_str = config.FW_USERNAME
password_str = config.FW_PASSWORD

# Microsoft credentials
microsoft_email = config.SENDER_EMAIL
microsoft_password = config.SENDER_PASSWORD

# SMTP email configuration
smtp_server = config.SMTP_SERVER
smtp_port = config.SMTP_PORT
smtp_username = config.SENDER_EMAIL
smtp_password = config.SENDER_PASSWORD

# Email details
email_to = ['yash.srivastava@fareportal.com', 'palak.verma@fareportal.com']
email_cc = ['akshat.jain@fareportal.com']

# Function to sign in to Microsoft
def sign_in(driver, email, password):
    EMAILFIELD = (By.ID, "i0116")
    PASSWORDFIELD = (By.ID, "i0118")
    NEXTBUTTON = (By.ID, "idSIButton9")

    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(EMAILFIELD)).send_keys(email)
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(NEXTBUTTON)).click()
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(PASSWORDFIELD)).send_keys(password)
    WebDriverWait(driver, 10).until(EC.element_to_be_clickable(NEXTBUTTON)).click()
    try:
        stay_signed_in_popup = driver.find_element(By.XPATH, "//div[contains(text(), 'Stay signed in?')]")
        if stay_signed_in_popup:
            no_button = driver.find_element(By.XPATH, "//input[@value='No']")
            no_button.click()
    except:
        pass

# Function to wait for file to be fully downloaded and rename it
def wait_for_download_and_rename(temp_dir, new_name, timeout=30):
    start_time = time.time()
    while True:
        for filename in os.listdir(temp_dir):
            if filename.endswith(".csv") and not filename.endswith(".crdownload"):
                full_path = os.path.join(temp_dir, filename)
                new_path = os.path.join(download_directory, new_name)
                shutil.move(full_path, new_path)
                print(f"File renamed and moved to {new_path}")
                return
        if time.time() - start_time > timeout:
            raise Exception(f"File download timed out after {timeout} seconds.")
        time.sleep(1)

# Function to export firewall policies
def export_policies(ip, location):
    service = Service(driver_path)
    driver = webdriver.Chrome(service=service, options=chrome_options)
    try:
        driver.get('https://login.microsoftonline.com/')
        sign_in(driver, microsoft_email, microsoft_password)
        driver.get(f'https://{ip}:8443/')
        try:
            advanced_button = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, "details-button")))
            advanced_button.click()
            proceed_link = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.ID, "proceed-link")))
            proceed_link.click()
        except Exception as e:
            print(f"No advanced option found or proceed (unsafe) link: {e}")
        try:
            accept_button = WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "//button[@name='accept']")))
            accept_button.click()
        except Exception as e:
            print(f"No accept button found: {e}")

        time.sleep(3)

        username = driver.find_element(By.ID, 'username')
        password = driver.find_element(By.ID, 'secretkey')
        login_button = driver.find_element(By.ID, 'login_button')

        username.send_keys(username_str)
        password.send_keys(password_str)
        login_button.click()

        time.sleep(5)

        # Handle special case for '172.16.125.20' with ?vdom=root
        if ip == '172.16.125.20':
            driver.get(f'https://{ip}:8443/ng/firewall/policy/policy/standard?vdom=root')
        else:
            driver.get(f'https://{ip}:8443/ng/firewall/policy/policy/standard')

        time.sleep(30)

        try:
            configure_table_button = WebDriverWait(driver, 30).until(
                EC.presence_of_element_located((By.XPATH, '//f-icon[@class="fa-cog"]'))
            )
            driver.execute_script("arguments[0].click();", configure_table_button)
            print("Clicked on configure table button using JavaScript")
        except Exception as e:
            print(f"Failed to click configure table button: {e}")
            driver.save_screenshot('error_screenshot.png')
            return

        options = [
            "Destination Address",
            "First Used",
            "Hit Count",
            "ID",
            "IPS",
            "Last Used",
            "Packets",
            "Source Address",
            "Status",
            "Comments"
        ]

        for option in options:
            try:
                button = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, f'//button[.//span[text()="{option}"]]'))
                )
                driver.execute_script("arguments[0].click();", button)
                print(f"Clicked on '{option}' button")
            except Exception as e:
                print(f"Failed to click on '{option}' button: {e}")

        try:
            apply_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, '//button[contains(@class, "standard-button primary") and text()="Apply"]'))
            )
            driver.execute_script("arguments[0].click();", apply_button)
            print("Clicked on Apply button")
        except Exception as e:
            print(f"Failed to click on Apply button: {e}")

        try:
            export_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, '//span[@class="ng-binding ng-scope" and text()="Export"]'))
            )
            driver.execute_script("arguments[0].click();", export_button)
            time.sleep(2)
            print("Clicked on Export button")
        except Exception as e:
            print(f"Failed to click on Export button: {e}")

        try:
            export_csv_option = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, '//span[@class="ng-scope" and text()="CSV"]'))
            )
            driver.execute_script("arguments[0].click();", export_csv_option)
            print("Clicked on CSV option")
        except Exception as e:
            print(f"Failed to click on CSV option: {e}")

        new_filename = f'firewall_policies_{location}.csv'
        time.sleep(5)
        wait_for_download_and_rename(temp_directory, new_filename)

    except Exception as e:
        print(f"An error occurred while exporting policies for {ip}: {e}")
        driver.save_screenshot('error_screenshot.png')
    finally:
        driver.quit()

os.makedirs(download_directory, exist_ok=True)
os.makedirs(temp_directory, exist_ok=True)

def apply_styles(sheet):
    header_font = Font(bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
    border_style = Side(border_style="thin", color="000000")
    header_border = Border(left=border_style, right=border_style, top=border_style, bottom=border_style)

    for row in sheet.iter_rows(min_row=1, max_row=1, min_col=1, max_col=sheet.max_column):
        for cell in row:
            cell.font = header_font
            cell.fill = header_fill
            cell.border = header_border

for ip, location in firewall_ips:
    export_policies(ip, location)

file_list = [f for f in os.listdir(download_directory) if f.endswith(".csv")]
combined_df = pd.DataFrame()
for file in file_list:
    file_path = os.path.join(download_directory, file)
    df = pd.read_csv(file_path, encoding='unicode_escape')
    df['Location'] = file.split('_')[-1].split('.')[0]
    combined_df = pd.concat([combined_df, df], ignore_index=True)

file_name = "Combined_Firewall_Policies.xlsx"
combined_df.to_excel(file_name, index=False)

wb = load_workbook(file_name)
ws = wb.active

last_used_df = combined_df[['Last Used', 'Hit Count']].copy()
last_used_df.dropna(subset=['Last Used'], inplace=True)
last_used_df['Last Used'] = pd.to_datetime(last_used_df['Last Used'], format='%Y-%m-%d', errors='coerce')
last_used_df = last_used_df.dropna(subset=['Last Used'])
last_used_df['Year-Month'] = last_used_df['Last Used'].dt.to_period('M')

last_used_df = last_used_df.groupby('Year-Month').agg({
    'Hit Count': 'sum',
    'Last Used': 'count'
}).reset_index()

last_used_df.rename(columns={'Last Used': 'Count'}, inplace=True)

if 'Last Used Month Wise' not in wb.sheetnames:
    wb.create_sheet('Last Used Month Wise')

last_used_sheet = wb['Last Used Month Wise']

for row in dataframe_to_rows(last_used_df, index=False, header=True):
    last_used_sheet.append(row)

apply_styles(last_used_sheet)

# Modify Last Used Month Wise sheet
last_used_df = combined_df[['Last Used', 'Hit Count']].dropna()
last_used_df['Last Used'] = pd.to_datetime(last_used_df['Last Used'])
last_used_df = last_used_df.sort_values(by='Last Used')

wb.create_sheet('Last Used Month Wise Modified')
sheet = wb['Last Used Month Wise Modified']

current_month = None
for _, row in last_used_df.iterrows():
    month_year = row['Last Used'].strftime('%Y-%m')
    if month_year != current_month:
        sheet.append([month_year])
        current_month = month_year
    sheet.append([row['Last Used'], row['Hit Count']])

# Adding a new sheet with Source and Destination as 'all'
source_dest_all_df = combined_df[(combined_df['Source Address'] == 'all') | (combined_df['Destination Address'] == 'all')]
wb.create_sheet('Source_Dest_All')
source_dest_all_sheet = wb['Source_Dest_All']

for row in dataframe_to_rows(source_dest_all_df, index=False, header=True):
    source_dest_all_sheet.append(row)

apply_styles(source_dest_all_sheet)

wb.save(file_name)

message = EmailMessage()
message["Subject"] = "Firewall Policies Report"
message["From"] = smtp_username
message["To"] = email_to
message["Cc"] = email_cc
message.set_content("Please find attached the firewall policies report.")

with open(file_name, "rb") as f:
    file_data = f.read()
    file_name = os.path.basename(file_name)
    message.add_attachment(file_data, maintype="application", subtype="vnd.openxmlformats-officedocument.spreadsheetml.sheet", filename=file_name)

with smtplib.SMTP(smtp_server, smtp_port) as server:
    server.starttls()
    server.login(smtp_username, smtp_password)
    server.send_message(message)

print("Email sent successfully.")
shutil.rmtree(download_directory)
shutil.rmtree(temp_directory)
